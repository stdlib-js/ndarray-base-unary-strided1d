{"version":3,"file":"index.mjs","sources":["../lib/strategy.js","../lib/increment_offsets.js","../lib/set_view_offsets.js","../lib/offsets.js","../lib/nd.js","../lib/main_factory.js","../lib/0d.js","../lib/1d.js","../lib/2d.js","../lib/3d.js","../lib/4d.js","../lib/5d.js","../lib/6d.js","../lib/7d.js","../lib/8d.js","../lib/9d.js","../lib/10d.js","../lib/2d_blocked.js","../lib/3d_blocked.js","../lib/4d_blocked.js","../lib/5d_blocked.js","../lib/6d_blocked.js","../lib/7d_blocked.js","../lib/8d_blocked.js","../lib/9d_blocked.js","../lib/10d_blocked.js","../lib/defaults.js","../lib/validate.js","../lib/initialize_array_views.js","../lib/main.js","../lib/factory.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport iterationOrder from '@stdlib/ndarray-base-iteration-order';\nimport { assign as minmaxViewBufferIndex } from '@stdlib/ndarray-base-minmax-view-buffer-index';\nimport ndarraylike2object from '@stdlib/ndarray-base-ndarraylike2object';\nimport assign from '@stdlib/ndarray-base-assign';\nimport ndarraylike2ndarray from '@stdlib/ndarray-base-ndarraylike2ndarray';\nimport emptyLike from '@stdlib/ndarray-base-empty-like';\n\n\n// FUNCTIONS //\n\n/**\n* Returns an input ndarray.\n*\n* @private\n* @param {ndarrayLike} x - input ndarray\n* @returns {ndarrayLike} input ndarray\n*/\nfunction identity( x ) {\n\treturn x;\n}\n\n/**\n* Broadcasts a zero-dimensional ndarray to a one-dimensional ndarray view containing a single element.\n*\n* @private\n* @param {ndarrayLike} x - input ndarray\n* @returns {ndarrayLike} broadcasted ndarray view\n*/\nfunction broadcast( x ) {\n\t// NOTE: the following properties must be set in the exact same order as in `x` in order to ensure that the returned object has the same hidden shape as the input ndarray-like object...\n\treturn {\n\t\t'dtype': x.dtype,\n\t\t'data': x.data,\n\t\t'shape': [ 1 ],\n\t\t'strides': [ 0 ],\n\t\t'offset': x.offset,\n\t\t'order': x.order\n\t};\n}\n\n/**\n* Returns a function which returns an ndarray view in which the singleton dimensions are removed from an input ndarray having only a single non-singleton dimension.\n*\n* @private\n* @param {ndarrayLike} arr - original ndarray\n* @param {NonNegativeInteger} index - index of the non-singleton dimension\n* @returns {Function} function for returning an ndarray view\n*/\nfunction squeeze( arr, index ) {\n\tvar sh = [ arr.shape[ index ] ];\n\tvar sx = [ arr.strides[ index ] ];\n\treturn reshape;\n\n\t/**\n\t* Returns an ndarray view in which the singleton dimensions are removed from an input ndarray having only a single non-singleton dimension.\n\t*\n\t* @private\n\t* @param {ndarrayLike} x - input ndarray\n\t* @returns {ndarrayLike} a squeezed ndarray view\n\t*/\n\tfunction reshape( x ) {\n\t\t// NOTE: the following properties must be set in the exact same order as in `arr` in order to ensure that the returned object has the same hidden shape as the input ndarray-like object...\n\t\treturn {\n\t\t\t'dtype': x.dtype,\n\t\t\t'data': x.data,\n\t\t\t'shape': sh,\n\t\t\t'strides': sx,\n\t\t\t'offset': x.offset,\n\t\t\t'order': x.order\n\t\t};\n\t}\n}\n\n/**\n* Returns a function which returns a one-dimensional ndarray view of a contiguous input ndarray having more than one dimension.\n*\n* @private\n* @param {NonNegativeInteger} len - number of elements in an ndarray\n* @param {integer} iox - iteration order\n* @returns {Function} function for returning a one-dimensional ndarray view\n*/\nfunction contiguous( len, iox ) {\n\tvar xmmv;\n\tvar ind;\n\tvar sh;\n\tvar sx;\n\n\t// Resolve the index of the min/max view buffer element which is the first indexed element...\n\tif ( iox === 1 ) {\n\t\tind = 0;\n\t} else {\n\t\tind = 1;\n\t}\n\t// Initialize an array for storing the min/max view buffer elements:\n\txmmv = [ 0, 0 ]; // [ min, max ]\n\n\t// Initialize the output one-dimensional view's shape and strides:\n\tsh = [ len ];\n\tsx = [ iox ];\n\n\treturn reshape;\n\n\t/**\n\t* Returns a one-dimensional ndarray view of a contiguous input ndarray having more than one dimension.\n\t*\n\t* @private\n\t* @param {ndarrayLike} x - input ndarray\n\t* @returns {ndarrayLike} a one-dimensional ndarray view\n\t*/\n\tfunction reshape( x ) {\n\t\t// Resolve the minimum and maximum linear indices in the underlying data buffer which are accessible to the input ndarray view:\n\t\tminmaxViewBufferIndex( x.shape, x.strides, x.offset, xmmv );\n\n\t\t// NOTE: the following properties must be set in the exact same order as in `x` in order to ensure that the returned object has the same hidden shape as the input ndarray-like object...\n\t\treturn {\n\t\t\t'dtype': x.dtype,\n\t\t\t'data': x.data,\n\t\t\t'shape': sh,\n\t\t\t'strides': sx,\n\t\t\t'offset': xmmv[ ind ], // the index of the first indexed element\n\t\t\t'order': x.order\n\t\t};\n\t}\n}\n\n/**\n* Returns a function which copies an input ndarray to a contiguous ndarray workspace.\n*\n* @private\n* @param {NonNegativeInteger} len - number of elements in an ndarray\n* @param {ndarrayLike} workspace - ndarray workspace\n* @returns {Function} function which copies an input ndarray to a contiguous ndarray workspace\n*/\nfunction copyToWorkspace( len, workspace ) {\n\t// NOTE: the following properties must be set in the exact same order as in the input ndarray-like object in order to ensure that the returned object has the same hidden shape...\n\tvar view = {\n\t\t'dtype': workspace.dtype,\n\t\t'data': workspace.data,\n\t\t'shape': [ len ],\n\t\t'strides': [ 1 ],\n\t\t'offset': workspace.offset,\n\t\t'order': workspace.order\n\t};\n\treturn reshape;\n\n\t/**\n\t* Copies an input ndarray to a contiguous ndarray workspace and returns a one-dimensional workspace view.\n\t*\n\t* @private\n\t* @param {ndarrayLike} x - input ndarray\n\t* @returns {ndarrayLike} one-dimensional workspace view\n\t*/\n\tfunction reshape( x ) {\n\t\tassign( [ x, workspace ] );\n\t\treturn view;\n\t}\n}\n\n/**\n* Returns a function which copies from a contiguous ndarray workspace to an input ndarray.\n*\n* @private\n* @param {ndarrayLike} workspace - ndarray workspace\n* @returns {Function} function which copies from a contiguous ndarray workspace to an input ndarray\n*/\nfunction copyFromWorkspace( workspace ) {\n\treturn copy;\n\n\t/**\n\t* Copies from a contiguous ndarray workspace to an input ndarray.\n\t*\n\t* @private\n\t* @param {ndarrayLike} x - input ndarray\n\t* @returns {ndarrayLike} input ndarray\n\t*/\n\tfunction copy( x ) {\n\t\tassign( [ workspace, x ] );\n\t\treturn x;\n\t}\n}\n\n\n// MAIN //\n\n/**\n* Returns an object for reshaping input ndarrays which have the same data type, shape, and strides as a provided ndarray.\n*\n* @private\n* @param {ndarrayLike} x - input ndarray\n* @param {string} x.dtype - input ndarray data type\n* @param {Collection} x.data - input ndarray data buffer\n* @param {NonNegativeIntegerArray} x.shape - input ndarray shape\n* @param {IntegerArray} x.strides - input ndarray strides\n* @param {NonNegativeInteger} x.offset - input ndarray index offset\n* @param {string} x.order - input ndarray memory layout\n* @returns {Object} object containing methods implementing a reshape strategy\n*/\nfunction strategy( x ) {\n\tvar workspace;\n\tvar ndims;\n\tvar xmmv;\n\tvar len;\n\tvar iox;\n\tvar sh;\n\tvar ns;\n\tvar i;\n\n\t// Resolve the number of array dimensions:\n\tsh = x.shape;\n\tndims = sh.length;\n\n\t// Check whether the ndarray is zero-dimensional...\n\tif ( ndims === 0 ) {\n\t\treturn {\n\t\t\t'input': broadcast,\n\t\t\t'output': identity\n\t\t};\n\t}\n\t// Check whether the ndarray is already one-dimensional...\n\tif ( ndims === 1 ) {\n\t\treturn {\n\t\t\t'input': identity,\n\t\t\t'output': identity\n\t\t};\n\t}\n\t// Determine the number of singleton dimensions...\n\tlen = 1; // number of elements\n\tns = 0;  // number of singleton dimensions\n\tfor ( i = 0; i < ndims; i++ ) {\n\t\t// Check whether the current dimension is a singleton dimension...\n\t\tif ( sh[ i ] === 1 ) {\n\t\t\tns += 1;\n\t\t}\n\t\tlen *= sh[ i ];\n\t}\n\t// Determine whether the ndarray has only **one** non-singleton dimension (e.g., ndims=4, shape=[10,1,1,1]) so that we can simply create an ndarray view without the singleton dimensions...\n\tif ( ns === ndims-1 ) {\n\t\t// Get the index of the non-singleton dimension...\n\t\tfor ( i = 0; i < ndims; i++ ) {\n\t\t\tif ( sh[ i ] !== 1 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\t'input': squeeze( x, i ),\n\t\t\t'output': identity\n\t\t};\n\t}\n\tiox = iterationOrder( x.strides ); // +/-1\n\n\t// Determine whether we can avoid copying data...\n\tif ( iox !== 0 ) {\n\t\t// Determine the minimum and maximum linear indices which are accessible by the ndarray view:\n\t\txmmv = minmaxViewBufferIndex( sh, x.strides, x.offset, [ 0, 0 ] );\n\n\t\t// Determine whether we can ignore shape (and strides) and create a new one-dimensional ndarray view...\n\t\tif ( len === ( xmmv[1]-xmmv[0]+1 ) ) {\n\t\t\treturn {\n\t\t\t\t'input': contiguous( len, iox ),\n\t\t\t\t'output': identity\n\t\t\t};\n\t\t}\n\t\t// The ndarray is non-contiguous, so we cannot directly interpret as a one-dimensional ndarray...\n\n\t\t// Fall-through to copying to a workspace ndarray...\n\t}\n\t// At this point, we're dealing with a non-contiguous multi-dimensional ndarray, so we need to copy to a contiguous workspace:\n\tworkspace = ndarraylike2object( emptyLike( ndarraylike2ndarray( x ) ) );\n\treturn {\n\t\t'input': copyToWorkspace( len, workspace ),\n\t\t'output': copyFromWorkspace( workspace )\n\t};\n}\n\n\n// EXPORTS //\n\nexport default strategy;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Increments index offsets according to a list of increments.\n*\n* ## Notes\n*\n* -   This function mutates the list of index offsets.\n*\n* @private\n* @param {NonNegativeIntegerArray} offsets - list of index offsets\n* @param {NonNegativeIntegerArray} inc - list of increments\n* @returns {NonNegativeIntegerArray} updated offsets\n*/\nfunction incrementOffsets( offsets, inc ) {\n\tvar i;\n\tfor ( i = 0; i < offsets.length; i++ ) {\n\t\toffsets[ i ] += inc[ i ];\n\t}\n\treturn offsets;\n}\n\n\n// EXPORTS //\n\nexport default incrementOffsets;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Sets view offsets according to a list of index offsets.\n*\n* ## Notes\n*\n* -   This function mutates the provides view objects.\n*\n* @private\n* @param {Array<Object>} views - list of ndarray-like objects representing ndarray views\n* @param {NonNegativeIntegerArray} offsets - list of index offsets\n* @returns {Array<Object>} updated views\n*/\nfunction setViewOffsets( views, offsets ) {\n\tvar i;\n\tfor ( i = 0; i < offsets.length; i++ ) {\n\t\tviews[ i ].offset = offsets[ i ];\n\t}\n\treturn views;\n}\n\n\n// EXPORTS //\n\nexport default setViewOffsets;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Resolves index offsets from a list of ndarray-like objects.\n*\n* @private\n* @param {ArrayLikeObject<Object>} arrays - list of ndarray-like objects\n* @returns {NonNegativeIntegerArray} list of offsets\n*/\nfunction offsets( arrays ) {\n\tvar out = [];\n\tvar i;\n\tfor ( i = 0; i < arrays.length; i++ ) {\n\t\tout.push( arrays[ i ].offset );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default offsets;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport numel from '@stdlib/ndarray-base-numel';\nimport vind2bind from '@stdlib/ndarray-base-vind2bind';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 3, 2, 2 ];\n* var ysh = [ 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n* var sy = [ 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 3 ],\n*     'strides': [ 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unarynd( wrapper, [ x, y, initial ], views, [ 3 ], [ 4 ], [ 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ]\n*/\nfunction unarynd( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar len;\n\tvar arr;\n\tvar iv;\n\tvar io;\n\tvar N;\n\tvar v;\n\tvar i;\n\tvar j;\n\n\tN = arrays.length;\n\n\t// Compute the total number of elements over which to iterate:\n\tlen = numel( shape );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate based on the linear **view** index, regardless as to how the data is stored in memory...\n\tio = zeros( N );\n\tfor ( i = 0; i < len; i++ ) {\n\t\tfor ( j = 0; j < N; j++ ) {\n\t\t\tarr = arrays[ j ];\n\t\t\tio[ j ] = vind2bind( shape, arr.strides, iv[ j ], arr.order, i, MODE ); // eslint-disable-line max-len\n\t\t}\n\t\tsetViewOffsets( views, io );\n\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\tfcn( v, opts );\n\t\tstrategyY.output( views[ 1 ] );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unarynd;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport ndarray2object from '@stdlib/ndarray-base-ndarraylike2object';\nimport normalizeIndices from '@stdlib/ndarray-base-to-unique-normalized-indices';\nimport indicesComplement from '@stdlib/array-base-indices-complement';\nimport takeIndexed2 from '@stdlib/array-base-take-indexed2';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport iterationOrder from '@stdlib/ndarray-base-iteration-order';\nimport strides2order from '@stdlib/ndarray-base-strides2order';\nimport numel from '@stdlib/ndarray-base-numel';\nimport join from '@stdlib/array-base-join';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport initializeViews from './initialize_array_views.js';\nimport strategy from './strategy.js';\nimport defaults from './defaults.js';\nimport validate from './validate.js';\nimport blockedunary2d from './2d_blocked.js';\nimport blockedunary3d from './3d_blocked.js';\nimport blockedunary4d from './4d_blocked.js';\nimport blockedunary5d from './5d_blocked.js';\nimport blockedunary6d from './6d_blocked.js';\nimport blockedunary7d from './7d_blocked.js';\nimport blockedunary8d from './8d_blocked.js';\nimport blockedunary9d from './9d_blocked.js';\nimport blockedunary10d from './10d_blocked.js';\nimport unary0d from './0d.js';\nimport unary1d from './1d.js';\nimport unary2d from './2d.js';\nimport unary3d from './3d.js';\nimport unary4d from './4d.js';\nimport unary5d from './5d.js';\nimport unary6d from './6d.js';\nimport unary7d from './7d.js';\nimport unary8d from './8d.js';\nimport unary9d from './9d.js';\nimport unary10d from './10d.js';\nimport unarynd from './nd.js';\n\n\n// VARIABLES //\n\nvar UNARY = [\n\tunary0d,\n\tunary1d,\n\tunary2d,\n\tunary3d,\n\tunary4d,\n\tunary5d,\n\tunary6d,\n\tunary7d,\n\tunary8d,\n\tunary9d,\n\tunary10d\n];\nvar BLOCKED_UNARY = [\n\tblockedunary2d, // 0\n\tblockedunary3d,\n\tblockedunary4d,\n\tblockedunary5d,\n\tblockedunary6d,\n\tblockedunary7d,\n\tblockedunary8d,\n\tblockedunary9d,\n\tblockedunary10d // 8\n];\nvar MAX_DIMS = UNARY.length - 1;\n\n\n// MAIN //\n\n/**\n* Returns a function for applying a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigning results to a provided output ndarray.\n*\n* @private\n* @param {Options} [options] - function options\n* @param {boolean} [options.strictTraversalOrder=false] - boolean specifying whether to require that element traversal match the memory layout of an input ndarray\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @returns {Function} function for applying a strided array function\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 3 ],\n*     'strides': [ 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply strided function:\n* var f = factory();\n* f( wrapper, [ x, y, initial ], [ 2, 3 ] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [],\n*     'strides': [ 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply strided function:\n* var f = factory();\n* f( wrapper, [ x, y, initial ], [ 0, 1, 2, 3 ] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 15.0, 21.0 ], [ 28.0, 36.0 ] ], [ [ 45.0, 55.0 ], [ 66.0, 78.0 ] ] ] ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 3, 2, 2 ];\n* var ysh = [ 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n* var sy = [ 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 3, 2, 2 ],\n*     'strides': [ 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply strided function:\n* var f = factory();\n* f( wrapper, [ x, y, initial ], [] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ 1.0, 2.0 ], [ 3.0, 4.0 ] ], [ [ 5.0, 6.0 ], [ 7.0, 8.0 ] ], [ [ 9.0, 10.0 ], [ 11.0, 12.0 ] ] ]\n*/\nfunction factory( options ) {\n\tvar OPTS;\n\tvar err;\n\n\tOPTS = defaults();\n\tif ( arguments.length ) {\n\t\terr = validate( OPTS, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\treturn unaryStrided1d;\n\n\t/**\n\t* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n\t*\n\t* @private\n\t* @param {Function} fcn - wrapper for a one-dimensional strided array function\n\t* @param {ArrayLikeObject<Object>} arrays - array-like object containing ndarrays\n\t* @param {IntegerArray} dims - list of dimensions to which to apply a strided array function\n\t* @param {Options} [options] - function options\n\t* @throws {Error} arrays must have the expected number of dimensions\n\t* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n\t* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n\t* @throws {Error} must provide unique dimension indices\n\t* @throws {Error} arrays must have the same loop dimension sizes\n\t* @returns {void}\n\t*/\n\tfunction unaryStrided1d( fcn, arrays, dims, options ) { // eslint-disable-line max-statements\n\t\tvar strategyX;\n\t\tvar strategyY;\n\t\tvar views;\n\t\tvar ndims;\n\t\tvar ldims;\n\t\tvar opts;\n\t\tvar arr;\n\t\tvar tmp;\n\t\tvar len;\n\t\tvar shl;\n\t\tvar shc;\n\t\tvar shx;\n\t\tvar iox;\n\t\tvar ioy;\n\t\tvar scx;\n\t\tvar scy;\n\t\tvar slx;\n\t\tvar sly;\n\t\tvar ord;\n\t\tvar ns;\n\t\tvar d;\n\t\tvar s;\n\t\tvar N;\n\t\tvar M;\n\t\tvar K;\n\t\tvar x;\n\t\tvar y;\n\t\tvar i;\n\t\tvar j;\n\n\t\tif ( arguments.length > 3 ) {\n\t\t\topts = options;\n\t\t} else {\n\t\t\topts = {};\n\t\t}\n\t\t// Standardize ndarray meta data...\n\t\tN = arrays.length;\n\t\tarr = [];\n\t\tfor ( i = 0; i < N; i++ ) {\n\t\t\tarr.push( ndarray2object( arrays[ i ] ) );\n\t\t}\n\t\t// Cache references to the input and output arrays:\n\t\tx = arr[ 0 ];\n\t\ty = arr[ 1 ];\n\n\t\t// Resolve the number of input array dimensions:\n\t\tshx = x.shape;\n\t\tndims = shx.length;\n\n\t\t// Verify that we've been provided a list of unique dimension indices...\n\t\tM = dims.length;\n\t\td = normalizeIndices( dims, ndims-1 );\n\t\tif ( d === null ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Third argument contains an out-of-bounds dimension index. Value: [%s].', join( dims, ',' ) ) );\n\t\t}\n\t\td.sort();\n\t\tif ( d.length !== M ) {\n\t\t\tthrow new Error( format( 'invalid argument. Third argument must contain a list of unique dimension indices. Value: [%s].', join( dims, ',' ) ) );\n\t\t}\n\t\t// Check whether we've been provided a valid number of dimensions...\n\t\tif ( M > ndims ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Number of specified dimensions cannot exceed the number of dimensions in the input array. Number of dimensions: %d. Value: [%s].', ndims, join( dims, ',' ) ) );\n\t\t}\n\t\t// Verify that provided ancillary ndarrays have the expected number of dimensions...\n\t\tK = ndims - M;\n\t\tfor ( i = 2; i < N; i++ ) {\n\t\t\tif ( arr[ i ].shape.length !== K ) {\n\t\t\t\tthrow new Error( format( 'invalid argument. Array arguments after the first two arrays must have the same number of loop dimensions. Input array shape: [%s]. Number of loop dimensions: %d. Array shape: [%s] (index: %d).', join( shx, ',' ), K, join( arr[ i ].shape, ',' ), i ) );\n\t\t\t}\n\t\t}\n\t\t// Verify that the input and output arrays have the same shape...\n\t\tif ( ndims !== y.shape.length ) {\n\t\t\tthrow new Error( 'invalid arguments. Input and output arrays must have the same shape.' );\n\t\t}\n\t\tfor ( i = 0; i < ndims; i++ ) {\n\t\t\tif ( shx[ i ] !== y.shape[ i ] ) {\n\t\t\t\tthrow new Error( 'invalid arguments. Input and output arrays must have the same shape.' );\n\t\t\t}\n\t\t}\n\t\t// Resolve the loop dimensions and associated strides:\n\t\tldims = indicesComplement( shx.length, d );\n\t\ttmp = takeIndexed2( shx, x.strides, ldims );\n\t\tshl = tmp[ 0 ];\n\t\tslx = tmp[ 1 ];\n\n\t\tsly = takeIndexed( y.strides, ldims );\n\n\t\t// Resolve the core dimensions and associated strides:\n\t\ttmp = takeIndexed2( shx, x.strides, d );\n\t\tshc = tmp[ 0 ];\n\t\tscx = tmp[ 1 ];\n\n\t\tscy = takeIndexed( y.strides, d );\n\n\t\t// Verify that provided ancillary arrays have the same loop dimensions...\n\t\tlen = 1; // number of elements\n\t\tns = 0;  // number of singleton dimensions\n\t\tfor ( i = 0; i < K; i++ ) {\n\t\t\ts = shl[ i ];\n\t\t\tfor ( j = 2; j < N; j++ ) {\n\t\t\t\tif ( s !== arr[ j ].shape[ i ] ) {\n\t\t\t\t\tthrow new Error( format( 'invalid argument. Loop dimensions must be consistent across all provided arrays. Input array shape: [%s]. Loop dimension indices: [%s]. Loop dimensions: [%s]. Array shape: [%s] (index: %d).', join( shx, ',' ), join( ldims, ',' ), join( shl, ',' ), join( arr[ j ].shape, ',' ), j ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Note that, if one of the dimensions is `0`, the length will be `0`...\n\t\t\tlen *= s;\n\n\t\t\t// Check whether the current dimension is a singleton dimension...\n\t\t\tif ( s === 1 ) {\n\t\t\t\tns += 1;\n\t\t\t}\n\t\t}\n\t\t// Check whether we were provided empty ndarrays...\n\t\tif ( len === 0 || ( shc.length && numel( shc ) === 0 ) ) {\n\t\t\treturn;\n\t\t}\n\t\t// Initialize ndarray-like objects for representing sub-array views...\n\t\tviews = [\n\t\t\t{\n\t\t\t\t'dtype': x.dtype,\n\t\t\t\t'data': x.data,\n\t\t\t\t'shape': shc,\n\t\t\t\t'strides': scx,\n\t\t\t\t'offset': x.offset,\n\t\t\t\t'order': x.order\n\t\t\t},\n\t\t\t{\n\t\t\t\t'dtype': y.dtype,\n\t\t\t\t'data': y.data,\n\t\t\t\t'shape': shc,\n\t\t\t\t'strides': scy,\n\t\t\t\t'offset': y.offset,\n\t\t\t\t'order': y.order\n\t\t\t}\n\t\t];\n\t\tinitializeViews( arr, views );\n\n\t\t// Determine the strategy for marshaling data to and from sub-array views of the input and output arrays before and after performing an operation:\n\t\tstrategyX = strategy( views[ 0 ] );\n\t\tstrategyY = strategy( views[ 1 ] );\n\n\t\t// Determine whether we can avoid iteration altogether...\n\t\tif ( K === 0 ) {\n\t\t\treturn UNARY[ K ]( fcn, arr, strategyX, strategyY, opts );\n\t\t}\n\t\t// Determine whether we only have one loop dimension and can thus readily perform one-dimensional iteration...\n\t\tif ( K === 1 ) {\n\t\t\treturn UNARY[ K ]( fcn, arr, views, shl, slx, sly, strategyX, strategyY, opts ); // eslint-disable-line max-len\n\t\t}\n\t\t// Determine whether the loop dimensions have only **one** non-singleton dimension (e.g., shape=[10,1,1,1]) so that we can treat loop iteration as being equivalent to one-dimensional iteration...\n\t\tif ( ns === K-1 ) {\n\t\t\t// Get the index of the non-singleton dimension...\n\t\t\tfor ( i = 0; i < K; i++ ) {\n\t\t\t\tif ( shl[ i ] !== 1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor ( j = 0; j < N; j++ ) {\n\t\t\t\tarr[ j ].strides = [ arr[j].strides[i] ];\n\t\t\t}\n\t\t\tslx = [ slx[i] ];\n\t\t\tsly = [ sly[i] ];\n\t\t\treturn UNARY[ 1 ]( fcn, arr, views, [ shl[i] ], slx, sly, strategyX, strategyY, opts ); // eslint-disable-line max-len\n\t\t}\n\t\tiox = iterationOrder( slx ); // +/-1\n\t\tioy = iterationOrder( sly ); // +/-1\n\n\t\t// Determine whether we can avoid blocked iteration...\n\t\tord = strides2order( slx );\n\t\tif ( iox !== 0 && ioy !== 0 && ord === strides2order( sly ) && K <= MAX_DIMS ) { // eslint-disable-line max-len\n\t\t\t// So long as iteration for each respective array always moves in the same direction (i.e., no mixed sign strides) and the memory layouts are the same, we can leverage cache-optimal (i.e., normal) nested loops without resorting to blocked iteration...\n\t\t\treturn UNARY[ K ]( fcn, arr, views, shl, slx, sly, ord === 1, strategyX, strategyY, opts ); // eslint-disable-line max-len\n\t\t}\n\t\t// Check whether blocked iteration is prohibited due to a requirement that the order of element traversal match the memory layout of a provided input ndarray...\n\t\tif ( OPTS.strictTraversalOrder && K <= MAX_DIMS ) {\n\t\t\t// We have two choices here: (1) we could copy to contiguous memory or (2) we can perform normal nested loop iteration, even though this is not cache-optimal based on the assumption that, while this may hurt performance, for many cases (i.e., smaller ndarrays), this should be fine and likely better than performing a complete copy...\n\t\t\treturn UNARY[ K ]( fcn, arr, views, shl, slx, sly, ord === 1, strategyX, strategyY, opts ); // eslint-disable-line max-len\n\t\t}\n\t\t// At this point, we're either dealing with non-contiguous n-dimensional arrays, high dimensional n-dimensional arrays, and/or arrays having differing memory layouts, so our only hope is that we can still perform blocked iteration...\n\n\t\t// Determine whether we can perform blocked iteration...\n\t\tif ( K <= MAX_DIMS ) {\n\t\t\treturn BLOCKED_UNARY[ K-2 ]( fcn, arr, views, shl, slx, sly, strategyX, strategyY, opts ); // eslint-disable-line max-len\n\t\t}\n\t\t// Perform linear view iteration without regard for how data is stored in memory (i.e., take the slow path)...\n\t\tunarynd( fcn, arr, views, shl, slx, sly, strategyX, strategyY, opts );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default factory;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 2, 2 ];\n* var ysh = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 1 ];\n* var sy = [ 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 3 ],\n*     'strides': [ 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary0d( wrapper, [ x, y, initial ], strategy, strategy, {} );\n*\n* var v = y.data;\n* // returns <Float64Array>[ 1.0, 3.0, 6.0, 10.0 ]\n*/\nfunction unary0d( fcn, arrays, strategyX, strategyY, opts ) {\n\tarrays[ 0 ] = strategyX.input( arrays[ 0 ] );\n\tarrays[ 1 ] = strategyY.input( arrays[ 1 ] );\n\tfcn( arrays, opts );\n\tstrategyY.output( arrays[ 1 ] );\n}\n\n\n// EXPORTS //\n\nexport default unary0d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 3, 2, 2 ];\n* var ysh = [ 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n* var sy = [ 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 3 ],\n*     'strides': [ 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary1d( wrapper, [ x, y, initial ], views, [ 3 ], [ 4 ], [ 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ]\n*/\nfunction unary1d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar dv0;\n\tvar S0;\n\tvar iv;\n\tvar i0;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = shape[ 0 ];\n\tdv0 = [\n\t\tstridesX[0],\n\t\tstridesY[0]\n\t];\n\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\tdv0.push( arrays[i].strides[0] );\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\tsetViewOffsets( views, iv );\n\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\tfcn( v, opts );\n\t\tstrategyY.output( views[ 1 ] );\n\t\tincrementOffsets( iv, dv0 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary1d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 3 ],\n*     'strides': [ 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary2d( wrapper, [ x, y, initial ], views, [ 1, 3 ], [ 12, 4 ], [ 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ]\n*/\nfunction unary2d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar dv0;\n\tvar dv1;\n\tvar S0;\n\tvar S1;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 1 ];\n\t\tS1 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[1],\n\t\t\tstridesY[1]\n\t\t];\n\t\tdv1 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S0*stridesX[1] ),\n\t\t\tstridesY[0] - ( S0*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[1] );\n\t\t\tdv1.push( sv[0] - ( S0*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tsetViewOffsets( views, iv );\n\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\tfcn( v, opts );\n\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\tincrementOffsets( iv, dv0 );\n\t\t}\n\t\tincrementOffsets( iv, dv1 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 3 ],\n*     'strides': [ 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary3d( wrapper, [ x, y, initial ], views, [ 1, 1, 3 ], [ 12, 12, 4 ], [ 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ]\n*/\nfunction unary3d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 2 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[2],\n\t\t\tstridesY[2]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[2] ),\n\t\t\tstridesY[1] - ( S0*stridesY[2] )\n\t\t];\n\t\tdv2 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S1*stridesX[1] ),\n\t\t\tstridesY[0] - ( S1*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[2] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[2] ) );\n\t\t\tdv2.push( sv[0] - ( S1*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\tfcn( v, opts );\n\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv1 );\n\t\t}\n\t\tincrementOffsets( iv, dv2 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary4d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 3 ], [ 12, 12, 12, 4 ], [ 12, 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ]\n*/\nfunction unary4d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 3 ];\n\t\tS1 = shape[ 2 ];\n\t\tS2 = shape[ 1 ];\n\t\tS3 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[3],\n\t\t\tstridesY[3]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[2] - ( S0*stridesX[3] ),\n\t\t\tstridesY[2] - ( S0*stridesY[3] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[1] - ( S1*stridesX[2] ),\n\t\t\tstridesY[1] - ( S1*stridesY[2] )\n\t\t];\n\t\tdv3 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S2*stridesX[1] ),\n\t\t\tstridesY[0] - ( S2*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[3] );\n\t\t\tdv1.push( sv[2] - ( S0*sv[3] ) );\n\t\t\tdv2.push( sv[1] - ( S1*sv[2] ) );\n\t\t\tdv3.push( sv[0] - ( S2*sv[1]) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 3 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tdv3 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[3] - ( S2*stridesX[2] ),\n\t\t\tstridesY[3] - ( S2*stridesY[2] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv2 );\n\t\t}\n\t\tincrementOffsets( iv, dv3 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary5d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ]\n*/\nfunction unary5d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 4 ];\n\t\tS1 = shape[ 3 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 1 ];\n\t\tS4 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[4],\n\t\t\tstridesY[4]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[3] - ( S0*stridesX[4] ),\n\t\t\tstridesY[3] - ( S0*stridesY[4] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[3] ),\n\t\t\tstridesY[2] - ( S1*stridesY[3] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[1] - ( S2*stridesX[2] ),\n\t\t\tstridesY[1] - ( S2*stridesY[2] )\n\t\t];\n\t\tdv4 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S3*stridesX[1] ),\n\t\t\tstridesY[0] - ( S3*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[4] );\n\t\t\tdv1.push( sv[3] - ( S0*sv[4] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[3] ) );\n\t\t\tdv3.push( sv[1] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[0] - ( S3*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 3 ];\n\t\tS4 = shape[ 4 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[3] - ( S2*stridesX[2] ),\n\t\t\tstridesY[3] - ( S2*stridesY[2] )\n\t\t];\n\t\tdv4 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[4] - ( S3*stridesX[3] ),\n\t\t\tstridesY[4] - ( S3*stridesY[3] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv3 );\n\t\t}\n\t\tincrementOffsets( iv, dv4 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary6d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ]\n*/\nfunction unary6d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 5 ];\n\t\tS1 = shape[ 4 ];\n\t\tS2 = shape[ 3 ];\n\t\tS3 = shape[ 2 ];\n\t\tS4 = shape[ 1 ];\n\t\tS5 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[5],\n\t\t\tstridesY[5]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[4] - ( S0*stridesX[5] ),\n\t\t\tstridesY[4] - ( S0*stridesY[5] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[3] - ( S1*stridesX[4] ),\n\t\t\tstridesY[3] - ( S1*stridesY[4] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[2] - ( S2*stridesX[3] ),\n\t\t\tstridesY[2] - ( S2*stridesY[3] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[1] - ( S3*stridesX[2] ),\n\t\t\tstridesY[1] - ( S3*stridesY[2] )\n\t\t];\n\t\tdv5 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S4*stridesX[1] ),\n\t\t\tstridesY[0] - ( S4*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[5] );\n\t\t\tdv1.push( sv[4] - ( S0*sv[5] ) );\n\t\t\tdv2.push( sv[3] - ( S1*sv[4] ) );\n\t\t\tdv3.push( sv[2] - ( S2*sv[3] ) );\n\t\t\tdv4.push( sv[1] - ( S3*sv[2] ) );\n\t\t\tdv5.push( sv[0] - ( S4*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 3 ];\n\t\tS4 = shape[ 4 ];\n\t\tS5 = shape[ 5 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[3] - ( S2*stridesX[2] ),\n\t\t\tstridesY[3] - ( S2*stridesY[2] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[4] - ( S3*stridesX[3] ),\n\t\t\tstridesY[4] - ( S3*stridesY[3] )\n\t\t];\n\t\tdv5 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[5] - ( S4*stridesX[4] ),\n\t\t\tstridesY[5] - ( S4*stridesY[4] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv4 );\n\t\t}\n\t\tincrementOffsets( iv, dv5 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary7d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ]\n*/\nfunction unary7d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 6 ];\n\t\tS1 = shape[ 5 ];\n\t\tS2 = shape[ 4 ];\n\t\tS3 = shape[ 3 ];\n\t\tS4 = shape[ 2 ];\n\t\tS5 = shape[ 1 ];\n\t\tS6 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[6],\n\t\t\tstridesY[6]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[5] - ( S0*stridesX[6] ),\n\t\t\tstridesY[5] - ( S0*stridesY[6] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[4] - ( S1*stridesX[5] ),\n\t\t\tstridesY[4] - ( S1*stridesY[5] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[3] - ( S2*stridesX[4] ),\n\t\t\tstridesY[3] - ( S2*stridesY[4] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[2] - ( S3*stridesX[3] ),\n\t\t\tstridesY[2] - ( S3*stridesY[3] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[1] - ( S4*stridesX[2] ),\n\t\t\tstridesY[1] - ( S4*stridesY[2] )\n\t\t];\n\t\tdv6 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S5*stridesX[1] ),\n\t\t\tstridesY[0] - ( S5*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[6] );\n\t\t\tdv1.push( sv[5] - ( S0*sv[6] ) );\n\t\t\tdv2.push( sv[4] - ( S1*sv[5] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[4] ) );\n\t\t\tdv4.push( sv[2] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[1] - ( S4*sv[2] ) );\n\t\t\tdv6.push( sv[0] - ( S5*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 3 ];\n\t\tS4 = shape[ 4 ];\n\t\tS5 = shape[ 5 ];\n\t\tS6 = shape[ 6 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[3] - ( S2*stridesX[2] ),\n\t\t\tstridesY[3] - ( S2*stridesY[2] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[4] - ( S3*stridesX[3] ),\n\t\t\tstridesY[4] - ( S3*stridesY[3] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[5] - ( S4*stridesX[4] ),\n\t\t\tstridesY[5] - ( S4*stridesY[4] )\n\t\t];\n\t\tdv6 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[6] - ( S5*stridesX[5] ),\n\t\t\tstridesY[6] - ( S5*stridesY[5] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv5 );\n\t\t}\n\t\tincrementOffsets( iv, dv6 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary8d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ] ]\n*/\nfunction unary8d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-len, max-statements\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 7 ];\n\t\tS1 = shape[ 6 ];\n\t\tS2 = shape[ 5 ];\n\t\tS3 = shape[ 4 ];\n\t\tS4 = shape[ 3 ];\n\t\tS5 = shape[ 2 ];\n\t\tS6 = shape[ 1 ];\n\t\tS7 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[7],\n\t\t\tstridesY[7]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[6] - ( S0*stridesX[7] ),\n\t\t\tstridesY[6] - ( S0*stridesY[7] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[5] - ( S1*stridesX[6] ),\n\t\t\tstridesY[5] - ( S1*stridesY[6] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[4] - ( S2*stridesX[5] ),\n\t\t\tstridesY[4] - ( S2*stridesY[5] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[3] - ( S3*stridesX[4] ),\n\t\t\tstridesY[3] - ( S3*stridesY[4] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[2] - ( S4*stridesX[3] ),\n\t\t\tstridesY[2] - ( S4*stridesY[3] )\n\t\t];\n\t\tdv6 = [\n\t\t\tstridesX[1] - ( S5*stridesX[2] ),\n\t\t\tstridesY[1] - ( S5*stridesY[2] )\n\t\t];\n\t\tdv7 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S6*stridesX[1] ),\n\t\t\tstridesY[0] - ( S6*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[7] );\n\t\t\tdv1.push( sv[6] - ( S0*sv[7] ) );\n\t\t\tdv2.push( sv[5] - ( S1*sv[6] ) );\n\t\t\tdv3.push( sv[4] - ( S2*sv[5] ) );\n\t\t\tdv4.push( sv[3] - ( S3*sv[4] ) );\n\t\t\tdv5.push( sv[2] - ( S4*sv[3] ) );\n\t\t\tdv6.push( sv[1] - ( S5*sv[2] ) );\n\t\t\tdv7.push( sv[0] - ( S6*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 3 ];\n\t\tS4 = shape[ 4 ];\n\t\tS5 = shape[ 5 ];\n\t\tS6 = shape[ 6 ];\n\t\tS7 = shape[ 7 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[3] - ( S2*stridesX[2] ),\n\t\t\tstridesY[3] - ( S2*stridesY[2] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[4] - ( S3*stridesX[3] ),\n\t\t\tstridesY[4] - ( S3*stridesY[3] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[5] - ( S4*stridesX[4] ),\n\t\t\tstridesY[5] - ( S4*stridesY[4] )\n\t\t];\n\t\tdv6 = [\n\t\t\tstridesX[6] - ( S5*stridesX[5] ),\n\t\t\tstridesY[6] - ( S5*stridesY[5] )\n\t\t];\n\t\tdv7 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[7] - ( S6*stridesX[6] ),\n\t\t\tstridesY[7] - ( S6*stridesY[6] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t\tdv7.push( sv[7] - ( S6*sv[6] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv6 );\n\t\t}\n\t\tincrementOffsets( iv, dv7 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary9d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ] ] ]\n*/\nfunction unary9d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-statements\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 8 ];\n\t\tS1 = shape[ 7 ];\n\t\tS2 = shape[ 6 ];\n\t\tS3 = shape[ 5 ];\n\t\tS4 = shape[ 4 ];\n\t\tS5 = shape[ 3 ];\n\t\tS6 = shape[ 2 ];\n\t\tS7 = shape[ 1 ];\n\t\tS8 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[8],\n\t\t\tstridesY[8]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[7] - ( S0*stridesX[8] ),\n\t\t\tstridesY[7] - ( S0*stridesY[8] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[6] - ( S1*stridesX[7] ),\n\t\t\tstridesY[6] - ( S1*stridesY[7] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[5] - ( S2*stridesX[6] ),\n\t\t\tstridesY[5] - ( S2*stridesY[6] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[4] - ( S3*stridesX[5] ),\n\t\t\tstridesY[4] - ( S3*stridesY[5] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[3] - ( S4*stridesX[4] ),\n\t\t\tstridesY[3] - ( S4*stridesY[4] )\n\t\t];\n\t\tdv6 = [\n\t\t\tstridesX[2] - ( S5*stridesX[3] ),\n\t\t\tstridesY[2] - ( S5*stridesY[3] )\n\t\t];\n\t\tdv7 = [\n\t\t\tstridesX[1] - ( S6*stridesX[2] ),\n\t\t\tstridesY[1] - ( S6*stridesY[2] )\n\t\t];\n\t\tdv8 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S7*stridesX[1] ),\n\t\t\tstridesY[0] - ( S7*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[8] );\n\t\t\tdv1.push( sv[7] - ( S0*sv[8] ) );\n\t\t\tdv2.push( sv[6] - ( S1*sv[7] ) );\n\t\t\tdv3.push( sv[5] - ( S2*sv[6] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[5] ) );\n\t\t\tdv5.push( sv[3] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[2] - ( S5*sv[3] ) );\n\t\t\tdv7.push( sv[1] - ( S6*sv[2] ) );\n\t\t\tdv8.push( sv[0] - ( S7*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 3 ];\n\t\tS4 = shape[ 4 ];\n\t\tS5 = shape[ 5 ];\n\t\tS6 = shape[ 6 ];\n\t\tS7 = shape[ 7 ];\n\t\tS8 = shape[ 8 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[3] - ( S2*stridesX[2] ),\n\t\t\tstridesY[3] - ( S2*stridesY[2] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[4] - ( S3*stridesX[3] ),\n\t\t\tstridesY[4] - ( S3*stridesY[3] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[5] - ( S4*stridesX[4] ),\n\t\t\tstridesY[5] - ( S4*stridesY[4] )\n\t\t];\n\t\tdv6 = [\n\t\t\tstridesX[6] - ( S5*stridesX[5] ),\n\t\t\tstridesY[6] - ( S5*stridesY[5] )\n\t\t];\n\t\tdv7 = [\n\t\t\tstridesX[7] - ( S6*stridesX[6] ),\n\t\t\tstridesY[7] - ( S6*stridesY[6] )\n\t\t];\n\t\tdv8 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[8] - ( S7*stridesX[7] ),\n\t\t\tstridesY[8] - ( S7*stridesY[7] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t\tdv7.push( sv[7] - ( S6*sv[6] ) );\n\t\t\tdv8.push( sv[8] - ( S7*sv[7] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv7 );\n\t\t}\n\t\tincrementOffsets( iv, dv8 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary10d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ] ] ] ]\n*/\nfunction unary10d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar dv9;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar S9;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 9 ];\n\t\tS1 = shape[ 8 ];\n\t\tS2 = shape[ 7 ];\n\t\tS3 = shape[ 6 ];\n\t\tS4 = shape[ 5 ];\n\t\tS5 = shape[ 4 ];\n\t\tS6 = shape[ 3 ];\n\t\tS7 = shape[ 2 ];\n\t\tS8 = shape[ 1 ];\n\t\tS9 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[9],\n\t\t\tstridesY[9]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[8] - ( S0*stridesX[9] ),\n\t\t\tstridesY[8] - ( S0*stridesY[9] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[7] - ( S1*stridesX[8] ),\n\t\t\tstridesY[7] - ( S1*stridesY[8] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[6] - ( S2*stridesX[7] ),\n\t\t\tstridesY[6] - ( S2*stridesY[7] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[5] - ( S3*stridesX[6] ),\n\t\t\tstridesY[5] - ( S3*stridesY[6] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[4] - ( S4*stridesX[5] ),\n\t\t\tstridesY[4] - ( S4*stridesY[5] )\n\t\t];\n\t\tdv6 = [\n\t\t\tstridesX[3] - ( S5*stridesX[4] ),\n\t\t\tstridesY[3] - ( S5*stridesY[4] )\n\t\t];\n\t\tdv7 = [\n\t\t\tstridesX[2] - ( S6*stridesX[3] ),\n\t\t\tstridesY[2] - ( S6*stridesY[3] )\n\t\t];\n\t\tdv8 = [\n\t\t\tstridesX[1] - ( S7*stridesX[2] ),\n\t\t\tstridesY[1] - ( S7*stridesY[2] )\n\t\t];\n\t\tdv9 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S8*stridesX[1] ),\n\t\t\tstridesY[0] - ( S8*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[9] );\n\t\t\tdv1.push( sv[8] - ( S0*sv[9] ) );\n\t\t\tdv2.push( sv[7] - ( S1*sv[8] ) );\n\t\t\tdv3.push( sv[6] - ( S2*sv[7] ) );\n\t\t\tdv4.push( sv[5] - ( S3*sv[6] ) );\n\t\t\tdv5.push( sv[4] - ( S4*sv[5] ) );\n\t\t\tdv6.push( sv[3] - ( S5*sv[4] ) );\n\t\t\tdv7.push( sv[2] - ( S6*sv[3] ) );\n\t\t\tdv8.push( sv[1] - ( S7*sv[2] ) );\n\t\t\tdv9.push( sv[0] - ( S8*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 3 ];\n\t\tS4 = shape[ 4 ];\n\t\tS5 = shape[ 5 ];\n\t\tS6 = shape[ 6 ];\n\t\tS7 = shape[ 7 ];\n\t\tS8 = shape[ 8 ];\n\t\tS9 = shape[ 9 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[3] - ( S2*stridesX[2] ),\n\t\t\tstridesY[3] - ( S2*stridesY[2] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[4] - ( S3*stridesX[3] ),\n\t\t\tstridesY[4] - ( S3*stridesY[3] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[5] - ( S4*stridesX[4] ),\n\t\t\tstridesY[5] - ( S4*stridesY[4] )\n\t\t];\n\t\tdv6 = [\n\t\t\tstridesX[6] - ( S5*stridesX[5] ),\n\t\t\tstridesY[6] - ( S5*stridesY[5] )\n\t\t];\n\t\tdv7 = [\n\t\t\tstridesX[7] - ( S6*stridesX[6] ),\n\t\t\tstridesY[7] - ( S6*stridesY[6] )\n\t\t];\n\t\tdv8 = [\n\t\t\tstridesX[8] - ( S7*stridesX[7] ),\n\t\t\tstridesY[8] - ( S7*stridesY[7] )\n\t\t];\n\t\tdv9 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[9] - ( S8*stridesX[8] ),\n\t\t\tstridesY[9] - ( S8*stridesY[8] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t\tdv7.push( sv[7] - ( S6*sv[6] ) );\n\t\t\tdv8.push( sv[8] - ( S7*sv[7] ) );\n\t\t\tdv9.push( sv[9] - ( S8*sv[8] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i9 = 0; i9 < S9; i9++ ) {\n\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv8 );\n\t\t}\n\t\tincrementOffsets( iv, dv9 );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default unary10d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 3 ],\n*     'strides': [ 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary2d( wrapper, [ x, y, initial ], views, [ 1, 3 ], [ 12, 4 ], [ 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ]\n*/\nfunction blockedunary2d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar ov1;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar j0;\n\tvar j1;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tdv1 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\tif ( j1 < bsize ) {\n\t\t\ts1 = j1;\n\t\t\tj1 = 0;\n\t\t} else {\n\t\t\ts1 = bsize;\n\t\t\tj1 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov1[ k ] = ov[k] + ( j1*sv[k][1] );\n\t\t}\n\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\tif ( j0 < bsize ) {\n\t\t\t\ts0 = j0;\n\t\t\t\tj0 = 0;\n\t\t\t} else {\n\t\t\t\ts0 = bsize;\n\t\t\t\tj0 -= bsize;\n\t\t\t}\n\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t}\n\t\t\t// Iterate over the loop dimensions...\n\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary2d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 3 ],\n*     'strides': [ 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary3d( wrapper, [ x, y, initial ], views, [ 1, 1, 3 ], [ 12, 12, 4 ], [ 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ]\n*/\nfunction blockedunary3d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar ov1;\n\tvar ov2;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\tif ( j2 < bsize ) {\n\t\t\ts2 = j2;\n\t\t\tj2 = 0;\n\t\t} else {\n\t\t\ts2 = bsize;\n\t\t\tj2 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov2[ k ] = ov[k] + ( j2*sv[k][2] );\n\t\t}\n\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\tif ( j1 < bsize ) {\n\t\t\t\ts1 = j1;\n\t\t\t\tj1 = 0;\n\t\t\t} else {\n\t\t\t\ts1 = bsize;\n\t\t\t\tj1 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t}\n\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\ts0 = j0;\n\t\t\t\t\tj0 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts0 = bsize;\n\t\t\t\t\tj0 -= bsize;\n\t\t\t\t}\n\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t}\n\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary3d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary4d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 3 ], [ 12, 12, 12, 4 ], [ 12, 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ]\n*/\nfunction blockedunary4d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\tif ( j3 < bsize ) {\n\t\t\ts3 = j3;\n\t\t\tj3 = 0;\n\t\t} else {\n\t\t\ts3 = bsize;\n\t\t\tj3 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov3[ k ] = ov[k] + ( j3*sv[k][3] );\n\t\t}\n\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\tif ( j2 < bsize ) {\n\t\t\t\ts2 = j2;\n\t\t\t\tj2 = 0;\n\t\t\t} else {\n\t\t\t\ts2 = bsize;\n\t\t\t\tj2 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t}\n\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\ts1 = j1;\n\t\t\t\t\tj1 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts1 = bsize;\n\t\t\t\t\tj1 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t}\n\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t}\n\t\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary4d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary5d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ]\n*/\nfunction blockedunary5d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\tif ( j4 < bsize ) {\n\t\t\ts4 = j4;\n\t\t\tj4 = 0;\n\t\t} else {\n\t\t\ts4 = bsize;\n\t\t\tj4 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov4[ k ] = ov[k] + ( j4*sv[k][4] );\n\t\t}\n\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\tif ( j3 < bsize ) {\n\t\t\t\ts3 = j3;\n\t\t\t\tj3 = 0;\n\t\t\t} else {\n\t\t\t\ts3 = bsize;\n\t\t\t\tj3 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t}\n\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\ts2 = j2;\n\t\t\t\t\tj2 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts2 = bsize;\n\t\t\t\t\tj2 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t}\n\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary5d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary6d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary6d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\tif ( j5 < bsize ) {\n\t\t\ts5 = j5;\n\t\t\tj5 = 0;\n\t\t} else {\n\t\t\ts5 = bsize;\n\t\t\tj5 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov5[ k ] = ov[k] + ( j5*sv[k][5] );\n\t\t}\n\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\tif ( j4 < bsize ) {\n\t\t\t\ts4 = j4;\n\t\t\t\tj4 = 0;\n\t\t\t} else {\n\t\t\t\ts4 = bsize;\n\t\t\t\tj4 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv5 = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t}\n\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\ts3 = j3;\n\t\t\t\t\tj3 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts3 = bsize;\n\t\t\t\t\tj3 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t}\n\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary6d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary7d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary7d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\tif ( j6 < bsize ) {\n\t\t\ts6 = j6;\n\t\t\tj6 = 0;\n\t\t} else {\n\t\t\ts6 = bsize;\n\t\t\tj6 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov6[ k ] = ov[k] + ( j6*sv[k][6] );\n\t\t}\n\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\tif ( j5 < bsize ) {\n\t\t\t\ts5 = j5;\n\t\t\t\tj5 = 0;\n\t\t\t} else {\n\t\t\t\ts5 = bsize;\n\t\t\t\tj5 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv6 = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t}\n\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\ts4 = j4;\n\t\t\t\t\tj4 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts4 = bsize;\n\t\t\t\t\tj4 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv5 = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t}\n\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary7d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary8d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary8d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar ov7;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tov7 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tdv7 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\tif ( j7 < bsize ) {\n\t\t\ts7 = j7;\n\t\t\tj7 = 0;\n\t\t} else {\n\t\t\ts7 = bsize;\n\t\t\tj7 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov7[ k ] = ov[k] + ( j7*sv[k][7] );\n\t\t}\n\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\tif ( j6 < bsize ) {\n\t\t\t\ts6 = j6;\n\t\t\t\tj6 = 0;\n\t\t\t} else {\n\t\t\t\ts6 = bsize;\n\t\t\t\tj6 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv7 = sv[k][7] - ( s6*sv[k][6] );\n\t\t\t\tov6[ k ] = ov7[k] + ( j6*sv[k][6] );\n\t\t\t}\n\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\ts5 = j5;\n\t\t\t\t\tj5 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts5 = bsize;\n\t\t\t\t\tj5 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv6 = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t\t}\n\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv5 = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary8d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary9d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary9d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar ov7;\n\tvar ov8;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tov7 = zeros( N );\n\tov8 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tdv7 = zeros( N );\n\tdv8 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\tif ( j8 < bsize ) {\n\t\t\ts8 = j8;\n\t\t\tj8 = 0;\n\t\t} else {\n\t\t\ts8 = bsize;\n\t\t\tj8 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov8[ k ] = ov[k] + ( j8*sv[k][8] );\n\t\t}\n\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\tif ( j7 < bsize ) {\n\t\t\t\ts7 = j7;\n\t\t\t\tj7 = 0;\n\t\t\t} else {\n\t\t\t\ts7 = bsize;\n\t\t\t\tj7 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv8 = sv[k][8] - ( s7*sv[k][7] );\n\t\t\t\tov7[ k ] = ov8[k] + ( j7*sv[k][7] );\n\t\t\t}\n\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\ts6 = j6;\n\t\t\t\t\tj6 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts6 = bsize;\n\t\t\t\t\tj6 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv7 = sv[k][7] - ( s6*sv[k][6] );\n\t\t\t\t\tov6[ k ] = ov7[k] + ( j6*sv[k][6] );\n\t\t\t\t}\n\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv6 = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv5 = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv8 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary9d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport loopOrder from '@stdlib/ndarray-base-unary-loop-interchange-order';\nimport blockSize from '@stdlib/ndarray-base-unary-tiling-block-size';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport copyIndexed from '@stdlib/array-base-copy-indexed';\nimport zeros from '@stdlib/array-base-zeros';\nimport incrementOffsets from './increment_offsets.js';\nimport setViewOffsets from './set_view_offsets.js';\nimport offsets from './offsets.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary10d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary10d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar dv9;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar ov7;\n\tvar ov8;\n\tvar ov9;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar s9;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar j9;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tov7 = zeros( N );\n\tov8 = zeros( N );\n\tov9 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tdv7 = zeros( N );\n\tdv8 = zeros( N );\n\tdv9 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j9 = sh[9]; j9 > 0; ) {\n\t\tif ( j9 < bsize ) {\n\t\t\ts9 = j9;\n\t\t\tj9 = 0;\n\t\t} else {\n\t\t\ts9 = bsize;\n\t\t\tj9 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov9[ k ] = ov[k] + ( j9*sv[k][9] );\n\t\t}\n\t\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\t\tif ( j8 < bsize ) {\n\t\t\t\ts8 = j8;\n\t\t\t\tj8 = 0;\n\t\t\t} else {\n\t\t\t\ts8 = bsize;\n\t\t\t\tj8 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv9 = sv[k][9] - ( s8*sv[k][8] );\n\t\t\t\tov8[ k ] = ov9[k] + ( j8*sv[k][8] );\n\t\t\t}\n\t\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\t\tif ( j7 < bsize ) {\n\t\t\t\t\ts7 = j7;\n\t\t\t\t\tj7 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts7 = bsize;\n\t\t\t\t\tj7 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv8 = sv[k][8] - ( s7*sv[k][7] );\n\t\t\t\t\tov7[ k ] = ov8[k] + ( j7*sv[k][7] );\n\t\t\t\t}\n\t\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\t\ts6 = j6;\n\t\t\t\t\t\tj6 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts6 = bsize;\n\t\t\t\t\t\tj6 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv7 = sv[k][7] - ( s6*sv[k][6] );\n\t\t\t\t\t\tov6[ k ] = ov7[k] + ( j6*sv[k][6] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv6 = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv5 = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\t\t\t\t\t\t\t\tfor ( i9 = 0; i9 < s9; i9++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv8 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv9 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nexport default blockedunary10d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Returns default options.\n*\n* @private\n* @returns {Object} default options\n*\n* @example\n* var o = defaults();\n* // returns {...}\n*/\nfunction defaults() {\n\treturn {\n\t\t// Require that the order of element traversal match the memory layout of an input ndarray:\n\t\t'strictTraversalOrder': false\n\t};\n}\n\n\n// EXPORTS //\n\nexport default defaults;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isObject from '@stdlib/assert-is-plain-object';\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport { isPrimitive as isBoolean } from '@stdlib/assert-is-boolean';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// MAIN //\n\n/**\n* Validates function options.\n*\n* @private\n* @param {Object} opts - destination object\n* @param {Options} options - function options\n* @param {boolean} [options.strictTraversalOrder] - boolean indicating whether the order of element traversal must match the memory layout order of an input ndarray\n* @returns {(Error|null)} null or an error object\n*\n* @example\n* var opts = {};\n* var options = {\n*     'strictTraversalOrder': true\n* };\n* var err = validate( opts, options );\n* if ( err ) {\n*     throw err;\n* }\n*/\nfunction validate( opts, options ) {\n\tif ( !isObject( options ) ) {\n\t\treturn new TypeError( format( 'null2V', options ) );\n\t}\n\tif ( hasOwnProp( options, 'strictTraversalOrder' ) ) {\n\t\topts.strictTraversalOrder = options.strictTraversalOrder;\n\t\tif ( !isBoolean( opts.strictTraversalOrder ) ) {\n\t\t\treturn new TypeError( format( 'null2o', 'strictTraversalOrder', opts.strictTraversalOrder ) );\n\t\t}\n\t}\n\treturn null;\n}\n\n\n// EXPORTS //\n\nexport default validate;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Initialize ndarray-like objects for representing zero-dimensional sub-array views of ancillary ndarray arguments.\n*\n* ## Notes\n*\n* -   This function ignores the first two ndarray-like objects, which are assumed to be the input and output ndarray, respectively.\n* -   This function mutates the provided output array.\n*\n* @private\n* @param {ArrayLikeObject<Object>} arrays - list of ndarray-like objects\n* @param {Array<Object>} out - output array\n* @returns {Array<Object>} output array\n*/\nfunction initializeViews( arrays, out ) {\n\tvar v;\n\tvar i;\n\n\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\tv = arrays[ i ];\n\t\tout.push({\n\t\t\t'dtype': v.dtype,\n\t\t\t'data': v.data,\n\t\t\t'shape': [],\n\t\t\t'strides': [ 0 ],\n\t\t\t'offset': v.offset,\n\t\t\t'order': v.order\n\t\t});\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default initializeViews;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport factory from './main_factory.js';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @name unaryStrided1d\n* @type {Function}\n* @param {Function} fcn - wrapper for a one-dimensional strided array function\n* @param {ArrayLikeObject<Object>} arrays - array-like object containing ndarrays\n* @param {IntegerArray} dims - list of dimensions to which to apply a strided array function\n* @param {Options} [options] - function options\n* @throws {Error} arrays must have the expected number of dimensions\n* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n* @throws {Error} must provide unique dimension indices\n* @throws {Error} arrays must have the same loop dimension sizes\n* @returns {void}\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 3 ],\n*     'strides': [ 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply strided function:\n* unaryStrided1d( wrapper, [ x, y, initial ], [ 2, 3 ] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [],\n*     'strides': [ 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply strided function:\n* unaryStrided1d( wrapper, [ x, y, initial ], [ 0, 1, 2, 3 ] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 15.0, 21.0 ], [ 28.0, 36.0 ] ], [ [ 45.0, 55.0 ], [ 66.0, 78.0 ] ] ] ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 3, 2, 2 ];\n* var ysh = [ 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n* var sy = [ 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 3, 2, 2 ],\n*     'strides': [ 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply strided function:\n* unaryStrided1d( wrapper, [ x, y, initial ], [] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ 1.0, 2.0 ], [ 3.0, 4.0 ] ], [ [ 5.0, 6.0 ], [ 7.0, 8.0 ] ], [ [ 9.0, 10.0 ], [ 11.0, 12.0 ] ] ]\n*/\nvar unaryStrided1d = factory();\n\n\n// EXPORTS //\n\nexport default unaryStrided1d;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isFunction from '@stdlib/assert-is-function';\nimport mainFactory from './main_factory.js';\nimport main from './main.js';\n\n\n// MAIN //\n\n/**\n* Return a function for applying a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigning results to a provided output ndarray.\n*\n* @param {Function} [fcn] - wrapper for a one-dimensional strided array function\n* @param {Options} [options] - function options\n* @param {boolean} [options.strictTraversalOrder=false] - boolean specifying whether to require that element traversal match the memory layout of an input ndarray\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @returns {Function} function for applying a strided array function\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 3 ],\n*     'strides': [ 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Create a function for applying a strided function:\n* var cusum = factory( wrapper );\n* // returns <Function>\n*\n* // Apply strided function:\n* cusum( [ x, y, initial ], [ 2, 3 ] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ]\n*/\nfunction factory() {\n\tvar nargs;\n\tvar unary;\n\tvar fcn;\n\tvar f;\n\n\tnargs = arguments.length;\n\n\t// Case: factory()\n\tif ( nargs === 0 ) {\n\t\tunary = main;\n\t\tf = wrap;\n\t}\n\t// Case: factory( fcn, opts )\n\telse if ( nargs > 1 ) {\n\t\tunary = mainFactory( arguments[ 1 ] );\n\t\tfcn = arguments[ 0 ];\n\t\tf = apply;\n\t}\n\t// Case: factory( fcn )\n\telse if ( isFunction( arguments[ 0 ] ) ) {\n\t\tunary = main;\n\t\tfcn = arguments[ 0 ];\n\t\tf = apply;\n\t}\n\t// Case: factory( opts )\n\telse {\n\t\tunary = mainFactory( arguments[ 0 ] );\n\t\tf = wrap;\n\t}\n\treturn f;\n\n\t/**\n\t* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n\t*\n\t* @private\n\t* @param {ArrayLikeObject<Object>} arrays - array-like object containing ndarrays\n\t* @param {IntegerArray} dims - list of dimensions to which to apply a strided array function\n\t* @param {Options} [options] - function options\n\t* @returns {void}\n\t*/\n\tfunction apply( arrays, dims, options ) {\n\t\tvar opts;\n\t\tif ( arguments.length > 2 ) {\n\t\t\topts = options;\n\t\t} else {\n\t\t\topts = {};\n\t\t}\n\t\treturn unary( fcn, arrays, dims, opts );\n\t}\n\n\t/**\n\t* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n\t*\n\t* @private\n\t* @param {Function} fcn - wrapper for a one-dimensional strided array function\n\t* @param {ArrayLikeObject<Object>} arrays - array-like object containing ndarrays\n\t* @param {IntegerArray} dims - list of dimensions to which to apply a strided array function\n\t* @param {Options} [options] - function options\n\t* @returns {void}\n\t*/\n\tfunction wrap( fcn, arrays, dims, options ) {\n\t\tvar opts;\n\t\tif ( arguments.length > 3 ) {\n\t\t\topts = options;\n\t\t} else {\n\t\t\topts = {};\n\t\t}\n\t\treturn unary( fcn, arrays, dims, opts );\n\t}\n}\n\n\n// EXPORTS //\n\nexport default factory;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Apply a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assign results to a provided output ndarray.\n*\n* @module @stdlib/ndarray-base-unary-strided1d\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n* import unaryStrided1d from '@stdlib/ndarray-base-unary-strided1d';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 3 ],\n*     'strides': [ 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply strided function:\n* unaryStrided1d( wrapper, [ x, y, initial ], [ 2, 3 ] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ]\n*\n* @example\n* import Float64Array from '@stdlib/array-float64';\n* import ndarray2array from '@stdlib/ndarray-base-to-array';\n* import getStride from '@stdlib/ndarray-base-stride';\n* import getOffset from '@stdlib/ndarray-base-offset';\n* import getData from '@stdlib/ndarray-base-data-buffer';\n* import numelDimension from '@stdlib/ndarray-base-numel-dimension';\n* import ndarraylike2scalar from '@stdlib/ndarray-base-ndarraylike2scalar';\n* import { ndarray as gcusum } from '@stdlib/blas-ext-base-gcusum';\n* import unaryStrided1d from '@stdlib/ndarray-base-unary-strided1d';\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), ndarraylike2scalar( s ), getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 3 ],\n*     'strides': [ 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Create a function for applying a strided function:\n* var cusum = unaryStrided1d.factory( wrapper );\n* // returns <Function>\n*\n* // Apply strided function:\n* cusum( [ x, y, initial ], [ 2, 3 ] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ]\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport factory from './factory.js';\nimport main from './main.js';\n\n\n// MAIN //\n\nsetReadOnly( main, 'factory', factory );\n\n\n// EXPORTS //\n\nexport default main;\n"],"names":["identity","x","broadcast","dtype","data","shape","strides","offset","order","squeeze","arr","index","sh","sx","contiguous","len","iox","xmmv","ind","minmaxViewBufferIndex","copyToWorkspace","workspace","view","assign","copyFromWorkspace","strategy","ndims","ns","i","length","input","output","iterationOrder","ndarraylike2object","emptyLike","ndarraylike2ndarray","incrementOffsets","offsets","inc","setViewOffsets","views","arrays","out","push","MODE","UNARY","fcn","strategyX","strategyY","opts","stridesX","stridesY","dv0","S0","iv","i0","v","copyIndexed","isRowMajor","dv1","S1","sv","i1","dv2","S2","i2","dv3","S3","i3","dv4","S4","i4","dv5","S5","i5","dv6","S6","i6","dv7","S7","i7","dv8","S8","i8","dv9","S9","i9","BLOCKED_UNARY","bsize","ov1","s0","s1","ov","j0","j1","N","y","o","k","loopOrder","sy","takeIndexed","idx","blockSize","zeros","ov2","s2","j2","ov3","s3","j3","ov4","s4","j4","ov5","s5","j5","ov6","s6","j6","ov7","s7","j7","ov8","s8","j8","ov9","s9","j9","MAX_DIMS","factory","options","OPTS","err","strictTraversalOrder","arguments","isObject","hasOwnProp","isBoolean","TypeError","format","validate","dims","ldims","tmp","shl","shc","shx","ioy","scx","scy","slx","sly","ord","d","s","M","K","j","ndarray2object","normalizeIndices","RangeError","join","sort","Error","indicesComplement","takeIndexed2","numel","initializeViews","strides2order","io","vind2bind","unarynd","unaryStrided1d","nargs","unary","f","main","wrap","mainFactory","apply","isFunction","setReadOnly"],"mappings":"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"}