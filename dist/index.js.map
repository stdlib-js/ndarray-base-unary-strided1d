{
  "version": 3,
  "sources": ["../lib/initialize_array_views.js", "../lib/strategy.js", "../lib/defaults.js", "../lib/validate.js", "../lib/increment_offsets.js", "../lib/set_view_offsets.js", "../lib/offsets.js", "../lib/2d_blocked.js", "../lib/3d_blocked.js", "../lib/4d_blocked.js", "../lib/5d_blocked.js", "../lib/6d_blocked.js", "../lib/7d_blocked.js", "../lib/8d_blocked.js", "../lib/9d_blocked.js", "../lib/10d_blocked.js", "../lib/0d.js", "../lib/1d.js", "../lib/2d.js", "../lib/3d.js", "../lib/4d.js", "../lib/5d.js", "../lib/6d.js", "../lib/7d.js", "../lib/8d.js", "../lib/9d.js", "../lib/10d.js", "../lib/nd.js", "../lib/main_factory.js", "../lib/main.js", "../lib/factory.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Initialize ndarray-like objects for representing zero-dimensional sub-array views of ancillary ndarray arguments.\n*\n* ## Notes\n*\n* -   This function ignores the first two ndarray-like objects, which are assumed to be the input and output ndarray, respectively.\n* -   This function mutates the provided output array.\n*\n* @private\n* @param {ArrayLikeObject<Object>} arrays - list of ndarray-like objects\n* @param {Array<Object>} out - output array\n* @returns {Array<Object>} output array\n*/\nfunction initializeViews( arrays, out ) {\n\tvar v;\n\tvar i;\n\n\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\tv = arrays[ i ];\n\t\tout.push({\n\t\t\t'dtype': v.dtype,\n\t\t\t'data': v.data,\n\t\t\t'shape': [],\n\t\t\t'strides': [ 0 ],\n\t\t\t'offset': v.offset,\n\t\t\t'order': v.order\n\t\t});\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = initializeViews;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar iterationOrder = require( '@stdlib/ndarray-base-iteration-order' );\nvar minmaxViewBufferIndex = require( '@stdlib/ndarray-base-minmax-view-buffer-index' ).assign;\nvar ndarraylike2object = require( '@stdlib/ndarray-base-ndarraylike2object' );\nvar assign = require( '@stdlib/ndarray-base-assign' );\nvar ndarraylike2ndarray = require( '@stdlib/ndarray-base-ndarraylike2ndarray' );\nvar emptyLike = require( '@stdlib/ndarray-base-empty-like' );\n\n\n// FUNCTIONS //\n\n/**\n* Returns an input ndarray.\n*\n* @private\n* @param {ndarrayLike} x - input ndarray\n* @returns {ndarrayLike} input ndarray\n*/\nfunction identity( x ) {\n\treturn x;\n}\n\n/**\n* Broadcasts a zero-dimensional ndarray to a one-dimensional ndarray view containing a single element.\n*\n* @private\n* @param {ndarrayLike} x - input ndarray\n* @returns {ndarrayLike} broadcasted ndarray view\n*/\nfunction broadcast( x ) {\n\t// NOTE: the following properties must be set in the exact same order as in `x` in order to ensure that the returned object has the same hidden shape as the input ndarray-like object...\n\treturn {\n\t\t'dtype': x.dtype,\n\t\t'data': x.data,\n\t\t'shape': [ 1 ],\n\t\t'strides': [ 0 ],\n\t\t'offset': x.offset,\n\t\t'order': x.order\n\t};\n}\n\n/**\n* Returns a function which returns an ndarray view in which the singleton dimensions are removed from an input ndarray having only a single non-singleton dimension.\n*\n* @private\n* @param {ndarrayLike} arr - original ndarray\n* @param {NonNegativeInteger} index - index of the non-singleton dimension\n* @returns {Function} function for returning an ndarray view\n*/\nfunction squeeze( arr, index ) {\n\tvar sh = [ arr.shape[ index ] ];\n\tvar sx = [ arr.strides[ index ] ];\n\treturn reshape;\n\n\t/**\n\t* Returns an ndarray view in which the singleton dimensions are removed from an input ndarray having only a single non-singleton dimension.\n\t*\n\t* @private\n\t* @param {ndarrayLike} x - input ndarray\n\t* @returns {ndarrayLike} a squeezed ndarray view\n\t*/\n\tfunction reshape( x ) {\n\t\t// NOTE: the following properties must be set in the exact same order as in `arr` in order to ensure that the returned object has the same hidden shape as the input ndarray-like object...\n\t\treturn {\n\t\t\t'dtype': x.dtype,\n\t\t\t'data': x.data,\n\t\t\t'shape': sh,\n\t\t\t'strides': sx,\n\t\t\t'offset': x.offset,\n\t\t\t'order': x.order\n\t\t};\n\t}\n}\n\n/**\n* Returns a function which returns a one-dimensional ndarray view of a contiguous input ndarray having more than one dimension.\n*\n* @private\n* @param {NonNegativeInteger} len - number of elements in an ndarray\n* @param {integer} iox - iteration order\n* @returns {Function} function for returning a one-dimensional ndarray view\n*/\nfunction contiguous( len, iox ) {\n\tvar xmmv;\n\tvar ind;\n\tvar sh;\n\tvar sx;\n\n\t// Resolve the index of the min/max view buffer element which is the first indexed element...\n\tif ( iox === 1 ) {\n\t\tind = 0;\n\t} else {\n\t\tind = 1;\n\t}\n\t// Initialize an array for storing the min/max view buffer elements:\n\txmmv = [ 0, 0 ]; // [ min, max ]\n\n\t// Initialize the output one-dimensional view's shape and strides:\n\tsh = [ len ];\n\tsx = [ iox ];\n\n\treturn reshape;\n\n\t/**\n\t* Returns a one-dimensional ndarray view of a contiguous input ndarray having more than one dimension.\n\t*\n\t* @private\n\t* @param {ndarrayLike} x - input ndarray\n\t* @returns {ndarrayLike} a one-dimensional ndarray view\n\t*/\n\tfunction reshape( x ) {\n\t\t// Resolve the minimum and maximum linear indices in the underlying data buffer which are accessible to the input ndarray view:\n\t\tminmaxViewBufferIndex( x.shape, x.strides, x.offset, xmmv );\n\n\t\t// NOTE: the following properties must be set in the exact same order as in `x` in order to ensure that the returned object has the same hidden shape as the input ndarray-like object...\n\t\treturn {\n\t\t\t'dtype': x.dtype,\n\t\t\t'data': x.data,\n\t\t\t'shape': sh,\n\t\t\t'strides': sx,\n\t\t\t'offset': xmmv[ ind ], // the index of the first indexed element\n\t\t\t'order': x.order\n\t\t};\n\t}\n}\n\n/**\n* Returns a function which copies an input ndarray to a contiguous ndarray workspace.\n*\n* @private\n* @param {NonNegativeInteger} len - number of elements in an ndarray\n* @param {ndarrayLike} workspace - ndarray workspace\n* @returns {Function} function which copies an input ndarray to a contiguous ndarray workspace\n*/\nfunction copyToWorkspace( len, workspace ) {\n\t// NOTE: the following properties must be set in the exact same order as in the input ndarray-like object in order to ensure that the returned object has the same hidden shape...\n\tvar view = {\n\t\t'dtype': workspace.dtype,\n\t\t'data': workspace.data,\n\t\t'shape': [ len ],\n\t\t'strides': [ 1 ],\n\t\t'offset': workspace.offset,\n\t\t'order': workspace.order\n\t};\n\treturn reshape;\n\n\t/**\n\t* Copies an input ndarray to a contiguous ndarray workspace and returns a one-dimensional workspace view.\n\t*\n\t* @private\n\t* @param {ndarrayLike} x - input ndarray\n\t* @returns {ndarrayLike} one-dimensional workspace view\n\t*/\n\tfunction reshape( x ) {\n\t\tassign( [ x, workspace ] );\n\t\treturn view;\n\t}\n}\n\n/**\n* Returns a function which copies from a contiguous ndarray workspace to an input ndarray.\n*\n* @private\n* @param {ndarrayLike} workspace - ndarray workspace\n* @returns {Function} function which copies from a contiguous ndarray workspace to an input ndarray\n*/\nfunction copyFromWorkspace( workspace ) {\n\treturn copy;\n\n\t/**\n\t* Copies from a contiguous ndarray workspace to an input ndarray.\n\t*\n\t* @private\n\t* @param {ndarrayLike} x - input ndarray\n\t* @returns {ndarrayLike} input ndarray\n\t*/\n\tfunction copy( x ) {\n\t\tassign( [ workspace, x ] );\n\t\treturn x;\n\t}\n}\n\n\n// MAIN //\n\n/**\n* Returns an object for reshaping input ndarrays which have the same data type, shape, and strides as a provided ndarray.\n*\n* @private\n* @param {ndarrayLike} x - input ndarray\n* @param {string} x.dtype - input ndarray data type\n* @param {Collection} x.data - input ndarray data buffer\n* @param {NonNegativeIntegerArray} x.shape - input ndarray shape\n* @param {IntegerArray} x.strides - input ndarray strides\n* @param {NonNegativeInteger} x.offset - input ndarray index offset\n* @param {string} x.order - input ndarray memory layout\n* @returns {Object} object containing methods implementing a reshape strategy\n*/\nfunction strategy( x ) {\n\tvar workspace;\n\tvar ndims;\n\tvar xmmv;\n\tvar len;\n\tvar iox;\n\tvar sh;\n\tvar ns;\n\tvar i;\n\n\t// Resolve the number of array dimensions:\n\tsh = x.shape;\n\tndims = sh.length;\n\n\t// Check whether the ndarray is zero-dimensional...\n\tif ( ndims === 0 ) {\n\t\treturn {\n\t\t\t'input': broadcast,\n\t\t\t'output': identity\n\t\t};\n\t}\n\t// Check whether the ndarray is already one-dimensional...\n\tif ( ndims === 1 ) {\n\t\treturn {\n\t\t\t'input': identity,\n\t\t\t'output': identity\n\t\t};\n\t}\n\t// Determine the number of singleton dimensions...\n\tlen = 1; // number of elements\n\tns = 0;  // number of singleton dimensions\n\tfor ( i = 0; i < ndims; i++ ) {\n\t\t// Check whether the current dimension is a singleton dimension...\n\t\tif ( sh[ i ] === 1 ) {\n\t\t\tns += 1;\n\t\t}\n\t\tlen *= sh[ i ];\n\t}\n\t// Determine whether the ndarray has only **one** non-singleton dimension (e.g., ndims=4, shape=[10,1,1,1]) so that we can simply create an ndarray view without the singleton dimensions...\n\tif ( ns === ndims-1 ) {\n\t\t// Get the index of the non-singleton dimension...\n\t\tfor ( i = 0; i < ndims; i++ ) {\n\t\t\tif ( sh[ i ] !== 1 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\t'input': squeeze( x, i ),\n\t\t\t'output': identity\n\t\t};\n\t}\n\tiox = iterationOrder( x.strides ); // +/-1\n\n\t// Determine whether we can avoid copying data...\n\tif ( iox !== 0 ) {\n\t\t// Determine the minimum and maximum linear indices which are accessible by the ndarray view:\n\t\txmmv = minmaxViewBufferIndex( sh, x.strides, x.offset, [ 0, 0 ] );\n\n\t\t// Determine whether we can ignore shape (and strides) and create a new one-dimensional ndarray view...\n\t\tif ( len === ( xmmv[1]-xmmv[0]+1 ) ) {\n\t\t\treturn {\n\t\t\t\t'input': contiguous( len, iox ),\n\t\t\t\t'output': identity\n\t\t\t};\n\t\t}\n\t\t// The ndarray is non-contiguous, so we cannot directly interpret as a one-dimensional ndarray...\n\n\t\t// Fall-through to copying to a workspace ndarray...\n\t}\n\t// At this point, we're dealing with a non-contiguous multi-dimensional ndarray, so we need to copy to a contiguous workspace:\n\tworkspace = ndarraylike2object( emptyLike( ndarraylike2ndarray( x ) ) );\n\treturn {\n\t\t'input': copyToWorkspace( len, workspace ),\n\t\t'output': copyFromWorkspace( workspace )\n\t};\n}\n\n\n// EXPORTS //\n\nmodule.exports = strategy;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Returns default options.\n*\n* @private\n* @returns {Object} default options\n*\n* @example\n* var o = defaults();\n* // returns {...}\n*/\nfunction defaults() {\n\treturn {\n\t\t// Require that the order of element traversal match the memory layout of an input ndarray:\n\t\t'strictTraversalOrder': false\n\t};\n}\n\n\n// EXPORTS //\n\nmodule.exports = defaults;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isObject = require( '@stdlib/assert-is-plain-object' );\nvar hasOwnProp = require( '@stdlib/assert-has-own-property' );\nvar isBoolean = require( '@stdlib/assert-is-boolean' ).isPrimitive;\nvar format = require( '@stdlib/string-format' );\n\n\n// MAIN //\n\n/**\n* Validates function options.\n*\n* @private\n* @param {Object} opts - destination object\n* @param {Options} options - function options\n* @param {boolean} [options.strictTraversalOrder] - boolean indicating whether the order of element traversal must match the memory layout order of an input ndarray\n* @returns {(Error|null)} null or an error object\n*\n* @example\n* var opts = {};\n* var options = {\n*     'strictTraversalOrder': true\n* };\n* var err = validate( opts, options );\n* if ( err ) {\n*     throw err;\n* }\n*/\nfunction validate( opts, options ) {\n\tif ( !isObject( options ) ) {\n\t\treturn new TypeError( format( 'invalid argument. Options argument must be an object. Value: `%s`.', options ) );\n\t}\n\tif ( hasOwnProp( options, 'strictTraversalOrder' ) ) {\n\t\topts.strictTraversalOrder = options.strictTraversalOrder;\n\t\tif ( !isBoolean( opts.strictTraversalOrder ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be a boolean. Option: `%s`.', 'strictTraversalOrder', opts.strictTraversalOrder ) );\n\t\t}\n\t}\n\treturn null;\n}\n\n\n// EXPORTS //\n\nmodule.exports = validate;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Increments index offsets according to a list of increments.\n*\n* ## Notes\n*\n* -   This function mutates the list of index offsets.\n*\n* @private\n* @param {NonNegativeIntegerArray} offsets - list of index offsets\n* @param {NonNegativeIntegerArray} inc - list of increments\n* @returns {NonNegativeIntegerArray} updated offsets\n*/\nfunction incrementOffsets( offsets, inc ) {\n\tvar i;\n\tfor ( i = 0; i < offsets.length; i++ ) {\n\t\toffsets[ i ] += inc[ i ];\n\t}\n\treturn offsets;\n}\n\n\n// EXPORTS //\n\nmodule.exports = incrementOffsets;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Sets view offsets according to a list of index offsets.\n*\n* ## Notes\n*\n* -   This function mutates the provides view objects.\n*\n* @private\n* @param {Array<Object>} views - list of ndarray-like objects representing ndarray views\n* @param {NonNegativeIntegerArray} offsets - list of index offsets\n* @returns {Array<Object>} updated views\n*/\nfunction setViewOffsets( views, offsets ) {\n\tvar i;\n\tfor ( i = 0; i < offsets.length; i++ ) {\n\t\tviews[ i ].offset = offsets[ i ];\n\t}\n\treturn views;\n}\n\n\n// EXPORTS //\n\nmodule.exports = setViewOffsets;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Resolves index offsets from a list of ndarray-like objects.\n*\n* @private\n* @param {ArrayLikeObject<Object>} arrays - list of ndarray-like objects\n* @returns {NonNegativeIntegerArray} list of offsets\n*/\nfunction offsets( arrays ) {\n\tvar out = [];\n\tvar i;\n\tfor ( i = 0; i < arrays.length; i++ ) {\n\t\tout.push( arrays[ i ].offset );\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = offsets;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-unary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-unary-tiling-block-size' );\nvar takeIndexed = require( '@stdlib/array-base-take-indexed' );\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 3 ],\n*     'strides': [ 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary2d( wrapper, [ x, y, initial ], views, [ 1, 3 ], [ 12, 4 ], [ 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ]\n*/\nfunction blockedunary2d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar ov1;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar j0;\n\tvar j1;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tdv1 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\tif ( j1 < bsize ) {\n\t\t\ts1 = j1;\n\t\t\tj1 = 0;\n\t\t} else {\n\t\t\ts1 = bsize;\n\t\t\tj1 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov1[ k ] = ov[k] + ( j1*sv[k][1] );\n\t\t}\n\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\tif ( j0 < bsize ) {\n\t\t\t\ts0 = j0;\n\t\t\t\tj0 = 0;\n\t\t\t} else {\n\t\t\t\ts0 = bsize;\n\t\t\t\tj0 -= bsize;\n\t\t\t}\n\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t}\n\t\t\t// Iterate over the loop dimensions...\n\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedunary2d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-unary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-unary-tiling-block-size' );\nvar takeIndexed = require( '@stdlib/array-base-take-indexed' );\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 3 ],\n*     'strides': [ 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary3d( wrapper, [ x, y, initial ], views, [ 1, 1, 3 ], [ 12, 12, 4 ], [ 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ]\n*/\nfunction blockedunary3d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar ov1;\n\tvar ov2;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\tif ( j2 < bsize ) {\n\t\t\ts2 = j2;\n\t\t\tj2 = 0;\n\t\t} else {\n\t\t\ts2 = bsize;\n\t\t\tj2 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov2[ k ] = ov[k] + ( j2*sv[k][2] );\n\t\t}\n\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\tif ( j1 < bsize ) {\n\t\t\t\ts1 = j1;\n\t\t\t\tj1 = 0;\n\t\t\t} else {\n\t\t\t\ts1 = bsize;\n\t\t\t\tj1 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t}\n\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\ts0 = j0;\n\t\t\t\t\tj0 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts0 = bsize;\n\t\t\t\t\tj0 -= bsize;\n\t\t\t\t}\n\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t}\n\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedunary3d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-unary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-unary-tiling-block-size' );\nvar takeIndexed = require( '@stdlib/array-base-take-indexed' );\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary4d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 3 ], [ 12, 12, 12, 4 ], [ 12, 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ]\n*/\nfunction blockedunary4d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\tif ( j3 < bsize ) {\n\t\t\ts3 = j3;\n\t\t\tj3 = 0;\n\t\t} else {\n\t\t\ts3 = bsize;\n\t\t\tj3 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov3[ k ] = ov[k] + ( j3*sv[k][3] );\n\t\t}\n\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\tif ( j2 < bsize ) {\n\t\t\t\ts2 = j2;\n\t\t\t\tj2 = 0;\n\t\t\t} else {\n\t\t\t\ts2 = bsize;\n\t\t\t\tj2 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t}\n\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\ts1 = j1;\n\t\t\t\t\tj1 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts1 = bsize;\n\t\t\t\t\tj1 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t}\n\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t}\n\t\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedunary4d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-unary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-unary-tiling-block-size' );\nvar takeIndexed = require( '@stdlib/array-base-take-indexed' );\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary5d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ]\n*/\nfunction blockedunary5d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\tif ( j4 < bsize ) {\n\t\t\ts4 = j4;\n\t\t\tj4 = 0;\n\t\t} else {\n\t\t\ts4 = bsize;\n\t\t\tj4 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov4[ k ] = ov[k] + ( j4*sv[k][4] );\n\t\t}\n\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\tif ( j3 < bsize ) {\n\t\t\t\ts3 = j3;\n\t\t\t\tj3 = 0;\n\t\t\t} else {\n\t\t\t\ts3 = bsize;\n\t\t\t\tj3 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t}\n\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\ts2 = j2;\n\t\t\t\t\tj2 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts2 = bsize;\n\t\t\t\t\tj2 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t}\n\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedunary5d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-unary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-unary-tiling-block-size' );\nvar takeIndexed = require( '@stdlib/array-base-take-indexed' );\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary6d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary6d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\tif ( j5 < bsize ) {\n\t\t\ts5 = j5;\n\t\t\tj5 = 0;\n\t\t} else {\n\t\t\ts5 = bsize;\n\t\t\tj5 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov5[ k ] = ov[k] + ( j5*sv[k][5] );\n\t\t}\n\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\tif ( j4 < bsize ) {\n\t\t\t\ts4 = j4;\n\t\t\t\tj4 = 0;\n\t\t\t} else {\n\t\t\t\ts4 = bsize;\n\t\t\t\tj4 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv5 = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t}\n\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\ts3 = j3;\n\t\t\t\t\tj3 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts3 = bsize;\n\t\t\t\t\tj3 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t}\n\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedunary6d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-unary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-unary-tiling-block-size' );\nvar takeIndexed = require( '@stdlib/array-base-take-indexed' );\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary7d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary7d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-statements\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\tif ( j6 < bsize ) {\n\t\t\ts6 = j6;\n\t\t\tj6 = 0;\n\t\t} else {\n\t\t\ts6 = bsize;\n\t\t\tj6 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov6[ k ] = ov[k] + ( j6*sv[k][6] );\n\t\t}\n\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\tif ( j5 < bsize ) {\n\t\t\t\ts5 = j5;\n\t\t\t\tj5 = 0;\n\t\t\t} else {\n\t\t\t\ts5 = bsize;\n\t\t\t\tj5 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv6 = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t}\n\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\ts4 = j4;\n\t\t\t\t\tj4 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts4 = bsize;\n\t\t\t\t\tj4 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv5 = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t}\n\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedunary7d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-unary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-unary-tiling-block-size' );\nvar takeIndexed = require( '@stdlib/array-base-take-indexed' );\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary8d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary8d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar ov7;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tov7 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tdv7 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\tif ( j7 < bsize ) {\n\t\t\ts7 = j7;\n\t\t\tj7 = 0;\n\t\t} else {\n\t\t\ts7 = bsize;\n\t\t\tj7 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov7[ k ] = ov[k] + ( j7*sv[k][7] );\n\t\t}\n\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\tif ( j6 < bsize ) {\n\t\t\t\ts6 = j6;\n\t\t\t\tj6 = 0;\n\t\t\t} else {\n\t\t\t\ts6 = bsize;\n\t\t\t\tj6 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv7 = sv[k][7] - ( s6*sv[k][6] );\n\t\t\t\tov6[ k ] = ov7[k] + ( j6*sv[k][6] );\n\t\t\t}\n\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\ts5 = j5;\n\t\t\t\t\tj5 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts5 = bsize;\n\t\t\t\t\tj5 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv6 = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t\t}\n\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv5 = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedunary8d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-unary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-unary-tiling-block-size' );\nvar takeIndexed = require( '@stdlib/array-base-take-indexed' );\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary9d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary9d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar ov7;\n\tvar ov8;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tov7 = zeros( N );\n\tov8 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tdv7 = zeros( N );\n\tdv8 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\tif ( j8 < bsize ) {\n\t\t\ts8 = j8;\n\t\t\tj8 = 0;\n\t\t} else {\n\t\t\ts8 = bsize;\n\t\t\tj8 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov8[ k ] = ov[k] + ( j8*sv[k][8] );\n\t\t}\n\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\tif ( j7 < bsize ) {\n\t\t\t\ts7 = j7;\n\t\t\t\tj7 = 0;\n\t\t\t} else {\n\t\t\t\ts7 = bsize;\n\t\t\t\tj7 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv8 = sv[k][8] - ( s7*sv[k][7] );\n\t\t\t\tov7[ k ] = ov8[k] + ( j7*sv[k][7] );\n\t\t\t}\n\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\ts6 = j6;\n\t\t\t\t\tj6 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts6 = bsize;\n\t\t\t\t\tj6 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv7 = sv[k][7] - ( s6*sv[k][6] );\n\t\t\t\t\tov6[ k ] = ov7[k] + ( j6*sv[k][6] );\n\t\t\t\t}\n\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv6 = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv5 = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv8 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedunary9d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar loopOrder = require( '@stdlib/ndarray-base-unary-loop-interchange-order' );\nvar blockSize = require( '@stdlib/ndarray-base-unary-tiling-block-size' );\nvar takeIndexed = require( '@stdlib/array-base-take-indexed' );\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray via loop blocking.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* blockedunary10d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ] ] ] ]\n*/\nfunction blockedunary10d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar bsize;\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar dv9;\n\tvar ov1;\n\tvar ov2;\n\tvar ov3;\n\tvar ov4;\n\tvar ov5;\n\tvar ov6;\n\tvar ov7;\n\tvar ov8;\n\tvar ov9;\n\tvar sh;\n\tvar s0;\n\tvar s1;\n\tvar s2;\n\tvar s3;\n\tvar s4;\n\tvar s5;\n\tvar s6;\n\tvar s7;\n\tvar s8;\n\tvar s9;\n\tvar sv;\n\tvar ov;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar j0;\n\tvar j1;\n\tvar j2;\n\tvar j3;\n\tvar j4;\n\tvar j5;\n\tvar j6;\n\tvar j7;\n\tvar j8;\n\tvar j9;\n\tvar N;\n\tvar x;\n\tvar y;\n\tvar v;\n\tvar o;\n\tvar k;\n\n\t// Note on variable naming convention: S#, dv#, i#, j# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\tN = arrays.length;\n\tx = arrays[ 0 ];\n\ty = arrays[ 1 ];\n\n\t// Resolve the loop interchange order:\n\to = loopOrder( shape, stridesX, stridesY );\n\tsh = o.sh;\n\tsv = [ o.sx, o.sy ];\n\tfor ( k = 2; k < N; k++ ) {\n\t\tsv.push( takeIndexed( arrays[k].strides, o.idx ) );\n\t}\n\t// Determine the block size:\n\tbsize = blockSize( x.dtype, y.dtype );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tov = offsets( arrays );\n\n\t// Cache offset increments for the innermost loop...\n\tdv0 = [];\n\tfor ( k = 0; k < N; k++ ) {\n\t\tdv0.push( sv[k][0] );\n\t}\n\t// Initialize loop variables...\n\tov1 = zeros( N );\n\tov2 = zeros( N );\n\tov3 = zeros( N );\n\tov4 = zeros( N );\n\tov5 = zeros( N );\n\tov6 = zeros( N );\n\tov7 = zeros( N );\n\tov8 = zeros( N );\n\tov9 = zeros( N );\n\tdv1 = zeros( N );\n\tdv2 = zeros( N );\n\tdv3 = zeros( N );\n\tdv4 = zeros( N );\n\tdv5 = zeros( N );\n\tdv6 = zeros( N );\n\tdv7 = zeros( N );\n\tdv8 = zeros( N );\n\tdv9 = zeros( N );\n\tiv = zeros( N );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over blocks...\n\tfor ( j9 = sh[9]; j9 > 0; ) {\n\t\tif ( j9 < bsize ) {\n\t\t\ts9 = j9;\n\t\t\tj9 = 0;\n\t\t} else {\n\t\t\ts9 = bsize;\n\t\t\tj9 -= bsize;\n\t\t}\n\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\tov9[ k ] = ov[k] + ( j9*sv[k][9] );\n\t\t}\n\t\tfor ( j8 = sh[8]; j8 > 0; ) {\n\t\t\tif ( j8 < bsize ) {\n\t\t\t\ts8 = j8;\n\t\t\t\tj8 = 0;\n\t\t\t} else {\n\t\t\t\ts8 = bsize;\n\t\t\t\tj8 -= bsize;\n\t\t\t}\n\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\tdv9 = sv[k][9] - ( s8*sv[k][8] );\n\t\t\t\tov8[ k ] = ov9[k] + ( j8*sv[k][8] );\n\t\t\t}\n\t\t\tfor ( j7 = sh[7]; j7 > 0; ) {\n\t\t\t\tif ( j7 < bsize ) {\n\t\t\t\t\ts7 = j7;\n\t\t\t\t\tj7 = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts7 = bsize;\n\t\t\t\t\tj7 -= bsize;\n\t\t\t\t}\n\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\tdv8 = sv[k][8] - ( s7*sv[k][7] );\n\t\t\t\t\tov7[ k ] = ov8[k] + ( j7*sv[k][7] );\n\t\t\t\t}\n\t\t\t\tfor ( j6 = sh[6]; j6 > 0; ) {\n\t\t\t\t\tif ( j6 < bsize ) {\n\t\t\t\t\t\ts6 = j6;\n\t\t\t\t\t\tj6 = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts6 = bsize;\n\t\t\t\t\t\tj6 -= bsize;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\tdv7 = sv[k][7] - ( s6*sv[k][6] );\n\t\t\t\t\t\tov6[ k ] = ov7[k] + ( j6*sv[k][6] );\n\t\t\t\t\t}\n\t\t\t\t\tfor ( j5 = sh[5]; j5 > 0; ) {\n\t\t\t\t\t\tif ( j5 < bsize ) {\n\t\t\t\t\t\t\ts5 = j5;\n\t\t\t\t\t\t\tj5 = 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ts5 = bsize;\n\t\t\t\t\t\t\tj5 -= bsize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\tdv6 = sv[k][6] - ( s5*sv[k][5] );\n\t\t\t\t\t\t\tov5[ k ] = ov6[k] + ( j5*sv[k][5] );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( j4 = sh[4]; j4 > 0; ) {\n\t\t\t\t\t\t\tif ( j4 < bsize ) {\n\t\t\t\t\t\t\t\ts4 = j4;\n\t\t\t\t\t\t\t\tj4 = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ts4 = bsize;\n\t\t\t\t\t\t\t\tj4 -= bsize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\tdv5 = sv[k][5] - ( s4*sv[k][4] );\n\t\t\t\t\t\t\t\tov4[ k ] = ov5[k] + ( j4*sv[k][4] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( j3 = sh[3]; j3 > 0; ) {\n\t\t\t\t\t\t\t\tif ( j3 < bsize ) {\n\t\t\t\t\t\t\t\t\ts3 = j3;\n\t\t\t\t\t\t\t\t\tj3 = 0;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts3 = bsize;\n\t\t\t\t\t\t\t\t\tj3 -= bsize;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\tdv4[ k ] = sv[k][4] - ( s3*sv[k][3] );\n\t\t\t\t\t\t\t\t\tov3[ k ] = ov4[k] + ( j3*sv[k][3] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor ( j2 = sh[2]; j2 > 0; ) {\n\t\t\t\t\t\t\t\t\tif ( j2 < bsize ) {\n\t\t\t\t\t\t\t\t\t\ts2 = j2;\n\t\t\t\t\t\t\t\t\t\tj2 = 0;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts2 = bsize;\n\t\t\t\t\t\t\t\t\t\tj2 -= bsize;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\tdv3[ k ] = sv[k][3] - ( s2*sv[k][2] );\n\t\t\t\t\t\t\t\t\t\tov2[ k ] = ov3[k] + ( j2*sv[k][2] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor ( j1 = sh[1]; j1 > 0; ) {\n\t\t\t\t\t\t\t\t\t\tif ( j1 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\ts1 = j1;\n\t\t\t\t\t\t\t\t\t\t\tj1 = 0;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts1 = bsize;\n\t\t\t\t\t\t\t\t\t\t\tj1 -= bsize;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\t\tdv2[ k ] = sv[k][2] - ( s1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t\t\tov1[ k ] = ov2[k] + ( j1*sv[k][1] );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor ( j0 = sh[0]; j0 > 0; ) {\n\t\t\t\t\t\t\t\t\t\t\tif ( j0 < bsize ) {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = j0;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 = 0;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\ts0 = bsize;\n\t\t\t\t\t\t\t\t\t\t\t\tj0 -= bsize;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Compute index offsets and loop offset increments for the first ndarray elements in the current block...\n\t\t\t\t\t\t\t\t\t\t\tfor ( k = 0; k < N; k++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tiv[ k ] = ov1[k] + ( j0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t\t\tdv1[ k ] = sv[k][1] - ( s0*sv[k][0] );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// Iterate over the loop dimensions...\n\t\t\t\t\t\t\t\t\t\t\tfor ( i9 = 0; i9 < s9; i9++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( i8 = 0; i8 < s8; i8++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i7 = 0; i7 < s7; i7++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i6 = 0; i6 < s6; i6++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i5 = 0; i5 < s5; i5++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i4 = 0; i4 < s4; i4++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i3 = 0; i3 < s3; i3++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < s2; i2++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < s1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < s0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv8 );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv9 );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = blockedunary10d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 2, 2 ];\n* var ysh = [ 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 2, 1 ];\n* var sy = [ 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 3 ],\n*     'strides': [ 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary0d( wrapper, [ x, y, initial ], strategy, strategy, {} );\n*\n* var v = y.data;\n* // returns <Float64Array>[ 1.0, 3.0, 6.0, 10.0 ]\n*/\nfunction unary0d( fcn, arrays, strategyX, strategyY, opts ) {\n\tarrays[ 0 ] = strategyX.input( arrays[ 0 ] );\n\tarrays[ 1 ] = strategyY.input( arrays[ 1 ] );\n\tfcn( arrays, opts );\n\tstrategyY.output( arrays[ 1 ] );\n}\n\n\n// EXPORTS //\n\nmodule.exports = unary0d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 3, 2, 2 ];\n* var ysh = [ 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n* var sy = [ 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 3 ],\n*     'strides': [ 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary1d( wrapper, [ x, y, initial ], views, [ 3 ], [ 4 ], [ 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ]\n*/\nfunction unary1d( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar dv0;\n\tvar S0;\n\tvar iv;\n\tvar i0;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tS0 = shape[ 0 ];\n\tdv0 = [\n\t\tstridesX[0],\n\t\tstridesY[0]\n\t];\n\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\tdv0.push( arrays[i].strides[0] );\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\tsetViewOffsets( views, iv );\n\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\tfcn( v, opts );\n\t\tstrategyY.output( views[ 1 ] );\n\t\tincrementOffsets( iv, dv0 );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = unary1d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 3 ],\n*     'strides': [ 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary2d( wrapper, [ x, y, initial ], views, [ 1, 3 ], [ 12, 4 ], [ 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ]\n*/\nfunction unary2d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar dv0;\n\tvar dv1;\n\tvar S0;\n\tvar S1;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 1 ];\n\t\tS1 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[1],\n\t\t\tstridesY[1]\n\t\t];\n\t\tdv1 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S0*stridesX[1] ),\n\t\t\tstridesY[0] - ( S0*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[1] );\n\t\t\tdv1.push( sv[0] - ( S0*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\tsetViewOffsets( views, iv );\n\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\tfcn( v, opts );\n\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\tincrementOffsets( iv, dv0 );\n\t\t}\n\t\tincrementOffsets( iv, dv1 );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = unary2d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 3 ],\n*     'strides': [ 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary3d( wrapper, [ x, y, initial ], views, [ 1, 1, 3 ], [ 12, 12, 4 ], [ 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ]\n*/\nfunction unary3d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 2 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[2],\n\t\t\tstridesY[2]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[2] ),\n\t\t\tstridesY[1] - ( S0*stridesY[2] )\n\t\t];\n\t\tdv2 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S1*stridesX[1] ),\n\t\t\tstridesY[0] - ( S1*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[2] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[2] ) );\n\t\t\tdv2.push( sv[0] - ( S1*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\tfcn( v, opts );\n\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv1 );\n\t\t}\n\t\tincrementOffsets( iv, dv2 );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = unary3d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary4d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 3 ], [ 12, 12, 12, 4 ], [ 12, 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ]\n*/\nfunction unary4d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 3 ];\n\t\tS1 = shape[ 2 ];\n\t\tS2 = shape[ 1 ];\n\t\tS3 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[3],\n\t\t\tstridesY[3]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[2] - ( S0*stridesX[3] ),\n\t\t\tstridesY[2] - ( S0*stridesY[3] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[1] - ( S1*stridesX[2] ),\n\t\t\tstridesY[1] - ( S1*stridesY[2] )\n\t\t];\n\t\tdv3 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S2*stridesX[1] ),\n\t\t\tstridesY[0] - ( S2*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[3] );\n\t\t\tdv1.push( sv[2] - ( S0*sv[3] ) );\n\t\t\tdv2.push( sv[1] - ( S1*sv[2] ) );\n\t\t\tdv3.push( sv[0] - ( S2*sv[1]) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 3 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tdv3 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[3] - ( S2*stridesX[2] ),\n\t\t\tstridesY[3] - ( S2*stridesY[2] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv2 );\n\t\t}\n\t\tincrementOffsets( iv, dv3 );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = unary4d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary5d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ]\n*/\nfunction unary5d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 4 ];\n\t\tS1 = shape[ 3 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 1 ];\n\t\tS4 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[4],\n\t\t\tstridesY[4]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[3] - ( S0*stridesX[4] ),\n\t\t\tstridesY[3] - ( S0*stridesY[4] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[3] ),\n\t\t\tstridesY[2] - ( S1*stridesY[3] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[1] - ( S2*stridesX[2] ),\n\t\t\tstridesY[1] - ( S2*stridesY[2] )\n\t\t];\n\t\tdv4 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S3*stridesX[1] ),\n\t\t\tstridesY[0] - ( S3*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[4] );\n\t\t\tdv1.push( sv[3] - ( S0*sv[4] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[3] ) );\n\t\t\tdv3.push( sv[1] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[0] - ( S3*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 3 ];\n\t\tS4 = shape[ 4 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[3] - ( S2*stridesX[2] ),\n\t\t\tstridesY[3] - ( S2*stridesY[2] )\n\t\t];\n\t\tdv4 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[4] - ( S3*stridesX[3] ),\n\t\t\tstridesY[4] - ( S3*stridesY[3] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv3 );\n\t\t}\n\t\tincrementOffsets( iv, dv4 );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = unary5d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary6d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ]\n*/\nfunction unary6d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 5 ];\n\t\tS1 = shape[ 4 ];\n\t\tS2 = shape[ 3 ];\n\t\tS3 = shape[ 2 ];\n\t\tS4 = shape[ 1 ];\n\t\tS5 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[5],\n\t\t\tstridesY[5]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[4] - ( S0*stridesX[5] ),\n\t\t\tstridesY[4] - ( S0*stridesY[5] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[3] - ( S1*stridesX[4] ),\n\t\t\tstridesY[3] - ( S1*stridesY[4] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[2] - ( S2*stridesX[3] ),\n\t\t\tstridesY[2] - ( S2*stridesY[3] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[1] - ( S3*stridesX[2] ),\n\t\t\tstridesY[1] - ( S3*stridesY[2] )\n\t\t];\n\t\tdv5 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S4*stridesX[1] ),\n\t\t\tstridesY[0] - ( S4*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[5] );\n\t\t\tdv1.push( sv[4] - ( S0*sv[5] ) );\n\t\t\tdv2.push( sv[3] - ( S1*sv[4] ) );\n\t\t\tdv3.push( sv[2] - ( S2*sv[3] ) );\n\t\t\tdv4.push( sv[1] - ( S3*sv[2] ) );\n\t\t\tdv5.push( sv[0] - ( S4*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 3 ];\n\t\tS4 = shape[ 4 ];\n\t\tS5 = shape[ 5 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[3] - ( S2*stridesX[2] ),\n\t\t\tstridesY[3] - ( S2*stridesY[2] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[4] - ( S3*stridesX[3] ),\n\t\t\tstridesY[4] - ( S3*stridesY[3] )\n\t\t];\n\t\tdv5 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[5] - ( S4*stridesX[4] ),\n\t\t\tstridesY[5] - ( S4*stridesY[4] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv4 );\n\t\t}\n\t\tincrementOffsets( iv, dv5 );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = unary6d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary7d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ]\n*/\nfunction unary7d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 6 ];\n\t\tS1 = shape[ 5 ];\n\t\tS2 = shape[ 4 ];\n\t\tS3 = shape[ 3 ];\n\t\tS4 = shape[ 2 ];\n\t\tS5 = shape[ 1 ];\n\t\tS6 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[6],\n\t\t\tstridesY[6]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[5] - ( S0*stridesX[6] ),\n\t\t\tstridesY[5] - ( S0*stridesY[6] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[4] - ( S1*stridesX[5] ),\n\t\t\tstridesY[4] - ( S1*stridesY[5] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[3] - ( S2*stridesX[4] ),\n\t\t\tstridesY[3] - ( S2*stridesY[4] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[2] - ( S3*stridesX[3] ),\n\t\t\tstridesY[2] - ( S3*stridesY[3] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[1] - ( S4*stridesX[2] ),\n\t\t\tstridesY[1] - ( S4*stridesY[2] )\n\t\t];\n\t\tdv6 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S5*stridesX[1] ),\n\t\t\tstridesY[0] - ( S5*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[6] );\n\t\t\tdv1.push( sv[5] - ( S0*sv[6] ) );\n\t\t\tdv2.push( sv[4] - ( S1*sv[5] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[4] ) );\n\t\t\tdv4.push( sv[2] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[1] - ( S4*sv[2] ) );\n\t\t\tdv6.push( sv[0] - ( S5*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 3 ];\n\t\tS4 = shape[ 4 ];\n\t\tS5 = shape[ 5 ];\n\t\tS6 = shape[ 6 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[3] - ( S2*stridesX[2] ),\n\t\t\tstridesY[3] - ( S2*stridesY[2] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[4] - ( S3*stridesX[3] ),\n\t\t\tstridesY[4] - ( S3*stridesY[3] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[5] - ( S4*stridesX[4] ),\n\t\t\tstridesY[5] - ( S4*stridesY[4] )\n\t\t];\n\t\tdv6 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[6] - ( S5*stridesX[5] ),\n\t\t\tstridesY[6] - ( S5*stridesY[5] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv5 );\n\t\t}\n\t\tincrementOffsets( iv, dv6 );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = unary7d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth */\n\n'use strict';\n\n// MODULES //\n\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary8d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ] ]\n*/\nfunction unary8d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-len, max-statements\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 7 ];\n\t\tS1 = shape[ 6 ];\n\t\tS2 = shape[ 5 ];\n\t\tS3 = shape[ 4 ];\n\t\tS4 = shape[ 3 ];\n\t\tS5 = shape[ 2 ];\n\t\tS6 = shape[ 1 ];\n\t\tS7 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[7],\n\t\t\tstridesY[7]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[6] - ( S0*stridesX[7] ),\n\t\t\tstridesY[6] - ( S0*stridesY[7] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[5] - ( S1*stridesX[6] ),\n\t\t\tstridesY[5] - ( S1*stridesY[6] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[4] - ( S2*stridesX[5] ),\n\t\t\tstridesY[4] - ( S2*stridesY[5] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[3] - ( S3*stridesX[4] ),\n\t\t\tstridesY[3] - ( S3*stridesY[4] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[2] - ( S4*stridesX[3] ),\n\t\t\tstridesY[2] - ( S4*stridesY[3] )\n\t\t];\n\t\tdv6 = [\n\t\t\tstridesX[1] - ( S5*stridesX[2] ),\n\t\t\tstridesY[1] - ( S5*stridesY[2] )\n\t\t];\n\t\tdv7 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S6*stridesX[1] ),\n\t\t\tstridesY[0] - ( S6*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[7] );\n\t\t\tdv1.push( sv[6] - ( S0*sv[7] ) );\n\t\t\tdv2.push( sv[5] - ( S1*sv[6] ) );\n\t\t\tdv3.push( sv[4] - ( S2*sv[5] ) );\n\t\t\tdv4.push( sv[3] - ( S3*sv[4] ) );\n\t\t\tdv5.push( sv[2] - ( S4*sv[3] ) );\n\t\t\tdv6.push( sv[1] - ( S5*sv[2] ) );\n\t\t\tdv7.push( sv[0] - ( S6*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 3 ];\n\t\tS4 = shape[ 4 ];\n\t\tS5 = shape[ 5 ];\n\t\tS6 = shape[ 6 ];\n\t\tS7 = shape[ 7 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[3] - ( S2*stridesX[2] ),\n\t\t\tstridesY[3] - ( S2*stridesY[2] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[4] - ( S3*stridesX[3] ),\n\t\t\tstridesY[4] - ( S3*stridesY[3] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[5] - ( S4*stridesX[4] ),\n\t\t\tstridesY[5] - ( S4*stridesY[4] )\n\t\t];\n\t\tdv6 = [\n\t\t\tstridesX[6] - ( S5*stridesX[5] ),\n\t\t\tstridesY[6] - ( S5*stridesY[5] )\n\t\t];\n\t\tdv7 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[7] - ( S6*stridesX[6] ),\n\t\t\tstridesY[7] - ( S6*stridesY[6] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t\tdv7.push( sv[7] - ( S6*sv[6] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv6 );\n\t\t}\n\t\tincrementOffsets( iv, dv7 );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = unary8d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary9d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ] ] ]\n*/\nfunction unary9d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-statements\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 8 ];\n\t\tS1 = shape[ 7 ];\n\t\tS2 = shape[ 6 ];\n\t\tS3 = shape[ 5 ];\n\t\tS4 = shape[ 4 ];\n\t\tS5 = shape[ 3 ];\n\t\tS6 = shape[ 2 ];\n\t\tS7 = shape[ 1 ];\n\t\tS8 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[8],\n\t\t\tstridesY[8]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[7] - ( S0*stridesX[8] ),\n\t\t\tstridesY[7] - ( S0*stridesY[8] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[6] - ( S1*stridesX[7] ),\n\t\t\tstridesY[6] - ( S1*stridesY[7] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[5] - ( S2*stridesX[6] ),\n\t\t\tstridesY[5] - ( S2*stridesY[6] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[4] - ( S3*stridesX[5] ),\n\t\t\tstridesY[4] - ( S3*stridesY[5] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[3] - ( S4*stridesX[4] ),\n\t\t\tstridesY[3] - ( S4*stridesY[4] )\n\t\t];\n\t\tdv6 = [\n\t\t\tstridesX[2] - ( S5*stridesX[3] ),\n\t\t\tstridesY[2] - ( S5*stridesY[3] )\n\t\t];\n\t\tdv7 = [\n\t\t\tstridesX[1] - ( S6*stridesX[2] ),\n\t\t\tstridesY[1] - ( S6*stridesY[2] )\n\t\t];\n\t\tdv8 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S7*stridesX[1] ),\n\t\t\tstridesY[0] - ( S7*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[8] );\n\t\t\tdv1.push( sv[7] - ( S0*sv[8] ) );\n\t\t\tdv2.push( sv[6] - ( S1*sv[7] ) );\n\t\t\tdv3.push( sv[5] - ( S2*sv[6] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[5] ) );\n\t\t\tdv5.push( sv[3] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[2] - ( S5*sv[3] ) );\n\t\t\tdv7.push( sv[1] - ( S6*sv[2] ) );\n\t\t\tdv8.push( sv[0] - ( S7*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 3 ];\n\t\tS4 = shape[ 4 ];\n\t\tS5 = shape[ 5 ];\n\t\tS6 = shape[ 6 ];\n\t\tS7 = shape[ 7 ];\n\t\tS8 = shape[ 8 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[3] - ( S2*stridesX[2] ),\n\t\t\tstridesY[3] - ( S2*stridesY[2] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[4] - ( S3*stridesX[3] ),\n\t\t\tstridesY[4] - ( S3*stridesY[3] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[5] - ( S4*stridesX[4] ),\n\t\t\tstridesY[5] - ( S4*stridesY[4] )\n\t\t];\n\t\tdv6 = [\n\t\t\tstridesX[6] - ( S5*stridesX[5] ),\n\t\t\tstridesY[6] - ( S5*stridesY[5] )\n\t\t];\n\t\tdv7 = [\n\t\t\tstridesX[7] - ( S6*stridesX[6] ),\n\t\t\tstridesY[7] - ( S6*stridesY[6] )\n\t\t];\n\t\tdv8 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[8] - ( S7*stridesX[7] ),\n\t\t\tstridesY[8] - ( S7*stridesY[7] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t\tdv7.push( sv[7] - ( S6*sv[6] ) );\n\t\t\tdv8.push( sv[8] - ( S7*sv[7] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv7 );\n\t\t}\n\t\tincrementOffsets( iv, dv8 );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = unary9d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable max-depth, max-len */\n\n'use strict';\n\n// MODULES //\n\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar incrementOffsets = require( './increment_offsets.js' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {boolean} isRowMajor - boolean indicating if provided arrays are in row-major order\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n* var ysh = [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n* var sy = [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 ],\n*     'strides': [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unary10d( wrapper, [ x, y, initial ], views, [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4 ], [ 12, 12, 12, 12, 12, 12, 12, 12, 12, 4 ], true, strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ [ [ [ [ [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ] ] ] ] ] ] ] ] ]\n*/\nfunction unary10d( fcn, arrays, views, shape, stridesX, stridesY, isRowMajor, strategyX, strategyY, opts ) { // eslint-disable-line max-statements, max-lines-per-function\n\tvar dv0;\n\tvar dv1;\n\tvar dv2;\n\tvar dv3;\n\tvar dv4;\n\tvar dv5;\n\tvar dv6;\n\tvar dv7;\n\tvar dv8;\n\tvar dv9;\n\tvar S0;\n\tvar S1;\n\tvar S2;\n\tvar S3;\n\tvar S4;\n\tvar S5;\n\tvar S6;\n\tvar S7;\n\tvar S8;\n\tvar S9;\n\tvar sv;\n\tvar iv;\n\tvar i0;\n\tvar i1;\n\tvar i2;\n\tvar i3;\n\tvar i4;\n\tvar i5;\n\tvar i6;\n\tvar i7;\n\tvar i8;\n\tvar i9;\n\tvar v;\n\tvar i;\n\n\t// Note on variable naming convention: S#, dv#, i# where # corresponds to the loop number, with `0` being the innermost loop...\n\n\t// Extract loop variables for purposes of loop interchange: dimensions and loop offset (pointer) increments...\n\tif ( isRowMajor ) {\n\t\t// For row-major ndarrays, the last dimensions have the fastest changing indices...\n\t\tS0 = shape[ 9 ];\n\t\tS1 = shape[ 8 ];\n\t\tS2 = shape[ 7 ];\n\t\tS3 = shape[ 6 ];\n\t\tS4 = shape[ 5 ];\n\t\tS5 = shape[ 4 ];\n\t\tS6 = shape[ 3 ];\n\t\tS7 = shape[ 2 ];\n\t\tS8 = shape[ 1 ];\n\t\tS9 = shape[ 0 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[9],\n\t\t\tstridesY[9]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[8] - ( S0*stridesX[9] ),\n\t\t\tstridesY[8] - ( S0*stridesY[9] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[7] - ( S1*stridesX[8] ),\n\t\t\tstridesY[7] - ( S1*stridesY[8] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[6] - ( S2*stridesX[7] ),\n\t\t\tstridesY[6] - ( S2*stridesY[7] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[5] - ( S3*stridesX[6] ),\n\t\t\tstridesY[5] - ( S3*stridesY[6] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[4] - ( S4*stridesX[5] ),\n\t\t\tstridesY[4] - ( S4*stridesY[5] )\n\t\t];\n\t\tdv6 = [\n\t\t\tstridesX[3] - ( S5*stridesX[4] ),\n\t\t\tstridesY[3] - ( S5*stridesY[4] )\n\t\t];\n\t\tdv7 = [\n\t\t\tstridesX[2] - ( S6*stridesX[3] ),\n\t\t\tstridesY[2] - ( S6*stridesY[3] )\n\t\t];\n\t\tdv8 = [\n\t\t\tstridesX[1] - ( S7*stridesX[2] ),\n\t\t\tstridesY[1] - ( S7*stridesY[2] )\n\t\t];\n\t\tdv9 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[0] - ( S8*stridesX[1] ),\n\t\t\tstridesY[0] - ( S8*stridesY[1] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[9] );\n\t\t\tdv1.push( sv[8] - ( S0*sv[9] ) );\n\t\t\tdv2.push( sv[7] - ( S1*sv[8] ) );\n\t\t\tdv3.push( sv[6] - ( S2*sv[7] ) );\n\t\t\tdv4.push( sv[5] - ( S3*sv[6] ) );\n\t\t\tdv5.push( sv[4] - ( S4*sv[5] ) );\n\t\t\tdv6.push( sv[3] - ( S5*sv[4] ) );\n\t\t\tdv7.push( sv[2] - ( S6*sv[3] ) );\n\t\t\tdv8.push( sv[1] - ( S7*sv[2] ) );\n\t\t\tdv9.push( sv[0] - ( S8*sv[1] ) );\n\t\t}\n\t} else { // order === 'column-major'\n\t\t// For column-major ndarrays, the first dimensions have the fastest changing indices...\n\t\tS0 = shape[ 0 ];\n\t\tS1 = shape[ 1 ];\n\t\tS2 = shape[ 2 ];\n\t\tS3 = shape[ 3 ];\n\t\tS4 = shape[ 4 ];\n\t\tS5 = shape[ 5 ];\n\t\tS6 = shape[ 6 ];\n\t\tS7 = shape[ 7 ];\n\t\tS8 = shape[ 8 ];\n\t\tS9 = shape[ 9 ];\n\t\tdv0 = [                                   // offset increment for innermost loop\n\t\t\tstridesX[0],\n\t\t\tstridesY[0]\n\t\t];\n\t\tdv1 = [\n\t\t\tstridesX[1] - ( S0*stridesX[0] ),\n\t\t\tstridesY[1] - ( S0*stridesY[0] )\n\t\t];\n\t\tdv2 = [\n\t\t\tstridesX[2] - ( S1*stridesX[1] ),\n\t\t\tstridesY[2] - ( S1*stridesY[1] )\n\t\t];\n\t\tdv3 = [\n\t\t\tstridesX[3] - ( S2*stridesX[2] ),\n\t\t\tstridesY[3] - ( S2*stridesY[2] )\n\t\t];\n\t\tdv4 = [\n\t\t\tstridesX[4] - ( S3*stridesX[3] ),\n\t\t\tstridesY[4] - ( S3*stridesY[3] )\n\t\t];\n\t\tdv5 = [\n\t\t\tstridesX[5] - ( S4*stridesX[4] ),\n\t\t\tstridesY[5] - ( S4*stridesY[4] )\n\t\t];\n\t\tdv6 = [\n\t\t\tstridesX[6] - ( S5*stridesX[5] ),\n\t\t\tstridesY[6] - ( S5*stridesY[5] )\n\t\t];\n\t\tdv7 = [\n\t\t\tstridesX[7] - ( S6*stridesX[6] ),\n\t\t\tstridesY[7] - ( S6*stridesY[6] )\n\t\t];\n\t\tdv8 = [\n\t\t\tstridesX[8] - ( S7*stridesX[7] ),\n\t\t\tstridesY[8] - ( S7*stridesY[7] )\n\t\t];\n\t\tdv9 = [                                   // offset increment for outermost loop\n\t\t\tstridesX[9] - ( S8*stridesX[8] ),\n\t\t\tstridesY[9] - ( S8*stridesY[8] )\n\t\t];\n\t\tfor ( i = 2; i < arrays.length; i++ ) {\n\t\t\tsv = arrays[ i ].strides;\n\t\t\tdv0.push( sv[0] );\n\t\t\tdv1.push( sv[1] - ( S0*sv[0] ) );\n\t\t\tdv2.push( sv[2] - ( S1*sv[1] ) );\n\t\t\tdv3.push( sv[3] - ( S2*sv[2] ) );\n\t\t\tdv4.push( sv[4] - ( S3*sv[3] ) );\n\t\t\tdv5.push( sv[5] - ( S4*sv[4] ) );\n\t\t\tdv6.push( sv[6] - ( S5*sv[5] ) );\n\t\t\tdv7.push( sv[7] - ( S6*sv[6] ) );\n\t\t\tdv8.push( sv[8] - ( S7*sv[7] ) );\n\t\t\tdv8.push( sv[8] - ( S8*sv[8] ) );\n\t\t}\n\t}\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate over the loop dimensions...\n\tfor ( i9 = 0; i9 < S9; i9++ ) {\n\t\tfor ( i8 = 0; i8 < S8; i8++ ) {\n\t\t\tfor ( i7 = 0; i7 < S7; i7++ ) {\n\t\t\t\tfor ( i6 = 0; i6 < S6; i6++ ) {\n\t\t\t\t\tfor ( i5 = 0; i5 < S5; i5++ ) {\n\t\t\t\t\t\tfor ( i4 = 0; i4 < S4; i4++ ) {\n\t\t\t\t\t\t\tfor ( i3 = 0; i3 < S3; i3++ ) {\n\t\t\t\t\t\t\t\tfor ( i2 = 0; i2 < S2; i2++ ) {\n\t\t\t\t\t\t\t\t\tfor ( i1 = 0; i1 < S1; i1++ ) {\n\t\t\t\t\t\t\t\t\t\tfor ( i0 = 0; i0 < S0; i0++ ) {\n\t\t\t\t\t\t\t\t\t\t\tsetViewOffsets( views, iv );\n\t\t\t\t\t\t\t\t\t\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\t\t\t\t\t\t\t\t\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\tfcn( v, opts );\n\t\t\t\t\t\t\t\t\t\t\tstrategyY.output( views[ 1 ] );\n\t\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv0 );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv1 );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tincrementOffsets( iv, dv2 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tincrementOffsets( iv, dv3 );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tincrementOffsets( iv, dv4 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tincrementOffsets( iv, dv5 );\n\t\t\t\t\t}\n\t\t\t\t\tincrementOffsets( iv, dv6 );\n\t\t\t\t}\n\t\t\t\tincrementOffsets( iv, dv7 );\n\t\t\t}\n\t\t\tincrementOffsets( iv, dv8 );\n\t\t}\n\t\tincrementOffsets( iv, dv9 );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = unary10d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar numel = require( '@stdlib/ndarray-base-numel' );\nvar vind2bind = require( '@stdlib/ndarray-base-vind2bind' );\nvar copyIndexed = require( '@stdlib/array-base-copy-indexed' );\nvar zeros = require( '@stdlib/array-base-zeros' );\nvar setViewOffsets = require( './set_view_offsets.js' );\nvar offsets = require( './offsets.js' );\n\n\n// VARIABLES //\n\nvar MODE = 'throw';\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @private\n* @param {Function} fcn - wrapper for a one-dimensional strided array reduction function\n* @param {Array<Object>} arrays - ndarrays\n* @param {Array<Object>} views - initialized ndarray-like objects representing sub-array views\n* @param {NonNegativeIntegerArray} shape - loop dimensions\n* @param {IntegerArray} stridesX - loop dimension strides for the input ndarray\n* @param {IntegerArray} stridesY - loop dimension strides for the output ndarray\n* @param {Object} strategyX - strategy for marshaling data to and from an input ndarray view\n* @param {Object} strategyY - strategy for marshaling data to and from an output ndarray view\n* @param {Options} opts - function options\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 3, 2, 2 ];\n* var ysh = [ 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n* var sy = [ 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 3 ],\n*     'strides': [ 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Initialize ndarray-like objects representing sub-array views:\n* var views = [\n*     {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     },\n*     {\n*         'dtype': y.dtype,\n*         'data': y.data,\n*         'shape': [ 2, 2 ],\n*         'strides': [ 2, 1 ],\n*         'offset': y.offset,\n*         'order': y.order\n*     },\n*     {\n*         'dtype': initial.dtype,\n*         'data': initial.data,\n*         'shape': [],\n*         'strides': [ 0 ],\n*         'offset': initial.offset,\n*         'order': initial.order\n*     }\n* ];\n*\n* // Define an input strategy:\n* function inputStrategy( x ) {\n*     return {\n*         'dtype': x.dtype,\n*         'data': x.data,\n*         'shape': [ 4 ],\n*         'strides': [ 1 ],\n*         'offset': x.offset,\n*         'order': x.order\n*     };\n* }\n*\n* // Define an output strategy:\n* function outputStrategy( x ) {\n*     return x;\n* }\n*\n* var strategy = {\n*     'input': inputStrategy,\n*     'output': outputStrategy\n* };\n*\n* // Apply strided function:\n* unarynd( wrapper, [ x, y, initial ], views, [ 3 ], [ 4 ], [ 4 ], strategy, strategy, {} );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ]\n*/\nfunction unarynd( fcn, arrays, views, shape, stridesX, stridesY, strategyX, strategyY, opts ) { // eslint-disable-line max-len\n\tvar len;\n\tvar arr;\n\tvar iv;\n\tvar io;\n\tvar N;\n\tvar v;\n\tvar i;\n\tvar j;\n\n\tN = arrays.length;\n\n\t// Compute the total number of elements over which to iterate:\n\tlen = numel( shape );\n\n\t// Resolve a list of pointers to the first indexed elements in the respective ndarrays:\n\tiv = offsets( arrays );\n\n\t// Shallow copy the list of views to an internal array so that we can update with reshaped views without impacting the original list of views:\n\tv = copyIndexed( views );\n\n\t// Iterate based on the linear **view** index, regardless as to how the data is stored in memory...\n\tio = zeros( N );\n\tfor ( i = 0; i < len; i++ ) {\n\t\tfor ( j = 0; j < N; j++ ) {\n\t\t\tarr = arrays[ j ];\n\t\t\tio[ j ] = vind2bind( shape, arr.strides, iv[ j ], arr.order, i, MODE ); // eslint-disable-line max-len\n\t\t}\n\t\tsetViewOffsets( views, io );\n\t\tv[ 0 ] = strategyX.input( views[ 0 ] );\n\t\tv[ 1 ] = strategyY.input( views[ 1 ] );\n\t\tfcn( v, opts );\n\t\tstrategyY.output( views[ 1 ] );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = unarynd;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar ndarray2object = require( '@stdlib/ndarray-base-ndarraylike2object' );\nvar normalizeIndices = require( '@stdlib/ndarray-base-to-unique-normalized-indices' );\nvar indicesComplement = require( '@stdlib/array-base-indices-complement' );\nvar takeIndexed2 = require( '@stdlib/array-base-take-indexed2' );\nvar takeIndexed = require( '@stdlib/array-base-take-indexed' );\nvar iterationOrder = require( '@stdlib/ndarray-base-iteration-order' );\nvar strides2order = require( '@stdlib/ndarray-base-strides2order' );\nvar numel = require( '@stdlib/ndarray-base-numel' );\nvar join = require( '@stdlib/array-base-join' );\nvar format = require( '@stdlib/string-format' );\nvar initializeViews = require( './initialize_array_views.js' );\nvar strategy = require( './strategy.js' );\nvar defaults = require( './defaults.js' );\nvar validate = require( './validate.js' );\nvar blockedunary2d = require( './2d_blocked.js' );\nvar blockedunary3d = require( './3d_blocked.js' );\nvar blockedunary4d = require( './4d_blocked.js' );\nvar blockedunary5d = require( './5d_blocked.js' );\nvar blockedunary6d = require( './6d_blocked.js' );\nvar blockedunary7d = require( './7d_blocked.js' );\nvar blockedunary8d = require( './8d_blocked.js' );\nvar blockedunary9d = require( './9d_blocked.js' );\nvar blockedunary10d = require( './10d_blocked.js' );\nvar unary0d = require( './0d.js' );\nvar unary1d = require( './1d.js' );\nvar unary2d = require( './2d.js' );\nvar unary3d = require( './3d.js' );\nvar unary4d = require( './4d.js' );\nvar unary5d = require( './5d.js' );\nvar unary6d = require( './6d.js' );\nvar unary7d = require( './7d.js' );\nvar unary8d = require( './8d.js' );\nvar unary9d = require( './9d.js' );\nvar unary10d = require( './10d.js' );\nvar unarynd = require( './nd.js' );\n\n\n// VARIABLES //\n\nvar UNARY = [\n\tunary0d,\n\tunary1d,\n\tunary2d,\n\tunary3d,\n\tunary4d,\n\tunary5d,\n\tunary6d,\n\tunary7d,\n\tunary8d,\n\tunary9d,\n\tunary10d\n];\nvar BLOCKED_UNARY = [\n\tblockedunary2d, // 0\n\tblockedunary3d,\n\tblockedunary4d,\n\tblockedunary5d,\n\tblockedunary6d,\n\tblockedunary7d,\n\tblockedunary8d,\n\tblockedunary9d,\n\tblockedunary10d // 8\n];\nvar MAX_DIMS = UNARY.length - 1;\n\n\n// MAIN //\n\n/**\n* Returns a function for applying a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigning results to a provided output ndarray.\n*\n* @private\n* @param {Options} [options] - function options\n* @param {boolean} [options.strictTraversalOrder=false] - boolean specifying whether to require that element traversal match the memory layout of an input ndarray\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @returns {Function} function for applying a strided array function\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 3 ],\n*     'strides': [ 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply strided function:\n* var f = factory();\n* f( wrapper, [ x, y, initial ], [ 2, 3 ] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [],\n*     'strides': [ 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply strided function:\n* var f = factory();\n* f( wrapper, [ x, y, initial ], [ 0, 1, 2, 3 ] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 15.0, 21.0 ], [ 28.0, 36.0 ] ], [ [ 45.0, 55.0 ], [ 66.0, 78.0 ] ] ] ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 3, 2, 2 ];\n* var ysh = [ 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n* var sy = [ 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 3, 2, 2 ],\n*     'strides': [ 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply strided function:\n* var f = factory();\n* f( wrapper, [ x, y, initial ], [] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ 1.0, 2.0 ], [ 3.0, 4.0 ] ], [ [ 5.0, 6.0 ], [ 7.0, 8.0 ] ], [ [ 9.0, 10.0 ], [ 11.0, 12.0 ] ] ]\n*/\nfunction factory( options ) {\n\tvar OPTS;\n\tvar err;\n\n\tOPTS = defaults();\n\tif ( arguments.length ) {\n\t\terr = validate( OPTS, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\treturn unaryStrided1d;\n\n\t/**\n\t* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n\t*\n\t* @private\n\t* @param {Function} fcn - wrapper for a one-dimensional strided array function\n\t* @param {ArrayLikeObject<Object>} arrays - array-like object containing ndarrays\n\t* @param {IntegerArray} dims - list of dimensions to which to apply a strided array function\n\t* @param {Options} [options] - function options\n\t* @throws {Error} arrays must have the expected number of dimensions\n\t* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n\t* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n\t* @throws {Error} must provide unique dimension indices\n\t* @throws {Error} arrays must have the same loop dimension sizes\n\t* @returns {void}\n\t*/\n\tfunction unaryStrided1d( fcn, arrays, dims, options ) { // eslint-disable-line max-statements\n\t\tvar strategyX;\n\t\tvar strategyY;\n\t\tvar views;\n\t\tvar ndims;\n\t\tvar ldims;\n\t\tvar opts;\n\t\tvar arr;\n\t\tvar tmp;\n\t\tvar len;\n\t\tvar shl;\n\t\tvar shc;\n\t\tvar shx;\n\t\tvar iox;\n\t\tvar ioy;\n\t\tvar scx;\n\t\tvar scy;\n\t\tvar slx;\n\t\tvar sly;\n\t\tvar ord;\n\t\tvar ns;\n\t\tvar d;\n\t\tvar s;\n\t\tvar N;\n\t\tvar M;\n\t\tvar K;\n\t\tvar x;\n\t\tvar y;\n\t\tvar i;\n\t\tvar j;\n\n\t\tif ( arguments.length > 3 ) {\n\t\t\topts = options;\n\t\t} else {\n\t\t\topts = {};\n\t\t}\n\t\t// Standardize ndarray meta data...\n\t\tN = arrays.length;\n\t\tarr = [];\n\t\tfor ( i = 0; i < N; i++ ) {\n\t\t\tarr.push( ndarray2object( arrays[ i ] ) );\n\t\t}\n\t\t// Cache references to the input and output arrays:\n\t\tx = arr[ 0 ];\n\t\ty = arr[ 1 ];\n\n\t\t// Resolve the number of input array dimensions:\n\t\tshx = x.shape;\n\t\tndims = shx.length;\n\n\t\t// Verify that we've been provided a list of unique dimension indices...\n\t\tM = dims.length;\n\t\td = normalizeIndices( dims, ndims-1 );\n\t\tif ( d === null ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Third argument contains an out-of-bounds dimension index. Value: [%s].', join( dims, ',' ) ) );\n\t\t}\n\t\td.sort();\n\t\tif ( d.length !== M ) {\n\t\t\tthrow new Error( format( 'invalid argument. Third argument must contain a list of unique dimension indices. Value: [%s].', join( dims, ',' ) ) );\n\t\t}\n\t\t// Check whether we've been provided a valid number of dimensions...\n\t\tif ( M > ndims ) {\n\t\t\tthrow new RangeError( format( 'invalid argument. Number of specified dimensions cannot exceed the number of dimensions in the input array. Number of dimensions: %d. Value: [%s].', ndims, join( dims, ',' ) ) );\n\t\t}\n\t\t// Verify that provided ancillary ndarrays have the expected number of dimensions...\n\t\tK = ndims - M;\n\t\tfor ( i = 2; i < N; i++ ) {\n\t\t\tif ( arr[ i ].shape.length !== K ) {\n\t\t\t\tthrow new Error( format( 'invalid argument. Array arguments after the first two arrays must have the same number of loop dimensions. Input array shape: [%s]. Number of loop dimensions: %d. Array shape: [%s] (index: %d).', join( shx, ',' ), K, join( arr[ i ].shape, ',' ), i ) );\n\t\t\t}\n\t\t}\n\t\t// Verify that the input and output arrays have the same shape...\n\t\tif ( ndims !== y.shape.length ) {\n\t\t\tthrow new Error( 'invalid arguments. Input and output arrays must have the same shape.' );\n\t\t}\n\t\tfor ( i = 0; i < ndims; i++ ) {\n\t\t\tif ( shx[ i ] !== y.shape[ i ] ) {\n\t\t\t\tthrow new Error( 'invalid arguments. Input and output arrays must have the same shape.' );\n\t\t\t}\n\t\t}\n\t\t// Resolve the loop dimensions and associated strides:\n\t\tldims = indicesComplement( shx.length, d );\n\t\ttmp = takeIndexed2( shx, x.strides, ldims );\n\t\tshl = tmp[ 0 ];\n\t\tslx = tmp[ 1 ];\n\n\t\tsly = takeIndexed( y.strides, ldims );\n\n\t\t// Resolve the core dimensions and associated strides:\n\t\ttmp = takeIndexed2( shx, x.strides, d );\n\t\tshc = tmp[ 0 ];\n\t\tscx = tmp[ 1 ];\n\n\t\tscy = takeIndexed( y.strides, d );\n\n\t\t// Verify that provided ancillary arrays have the same loop dimensions...\n\t\tlen = 1; // number of elements\n\t\tns = 0;  // number of singleton dimensions\n\t\tfor ( i = 0; i < K; i++ ) {\n\t\t\ts = shl[ i ];\n\t\t\tfor ( j = 2; j < N; j++ ) {\n\t\t\t\tif ( s !== arr[ j ].shape[ i ] ) {\n\t\t\t\t\tthrow new Error( format( 'invalid argument. Loop dimensions must be consistent across all provided arrays. Input array shape: [%s]. Loop dimension indices: [%s]. Loop dimensions: [%s]. Array shape: [%s] (index: %d).', join( shx, ',' ), join( ldims, ',' ), join( shl, ',' ), join( arr[ j ].shape, ',' ), j ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Note that, if one of the dimensions is `0`, the length will be `0`...\n\t\t\tlen *= s;\n\n\t\t\t// Check whether the current dimension is a singleton dimension...\n\t\t\tif ( s === 1 ) {\n\t\t\t\tns += 1;\n\t\t\t}\n\t\t}\n\t\t// Check whether we were provided empty ndarrays...\n\t\tif ( len === 0 || ( shc.length && numel( shc ) === 0 ) ) {\n\t\t\treturn;\n\t\t}\n\t\t// Initialize ndarray-like objects for representing sub-array views...\n\t\tviews = [\n\t\t\t{\n\t\t\t\t'dtype': x.dtype,\n\t\t\t\t'data': x.data,\n\t\t\t\t'shape': shc,\n\t\t\t\t'strides': scx,\n\t\t\t\t'offset': x.offset,\n\t\t\t\t'order': x.order\n\t\t\t},\n\t\t\t{\n\t\t\t\t'dtype': y.dtype,\n\t\t\t\t'data': y.data,\n\t\t\t\t'shape': shc,\n\t\t\t\t'strides': scy,\n\t\t\t\t'offset': y.offset,\n\t\t\t\t'order': y.order\n\t\t\t}\n\t\t];\n\t\tinitializeViews( arr, views );\n\n\t\t// Determine the strategy for marshaling data to and from sub-array views of the input and output arrays before and after performing an operation:\n\t\tstrategyX = strategy( views[ 0 ] );\n\t\tstrategyY = strategy( views[ 1 ] );\n\n\t\t// Determine whether we can avoid iteration altogether...\n\t\tif ( K === 0 ) {\n\t\t\treturn UNARY[ K ]( fcn, arr, strategyX, strategyY, opts );\n\t\t}\n\t\t// Determine whether we only have one loop dimension and can thus readily perform one-dimensional iteration...\n\t\tif ( K === 1 ) {\n\t\t\treturn UNARY[ K ]( fcn, arr, views, shl, slx, sly, strategyX, strategyY, opts ); // eslint-disable-line max-len\n\t\t}\n\t\t// Determine whether the loop dimensions have only **one** non-singleton dimension (e.g., shape=[10,1,1,1]) so that we can treat loop iteration as being equivalent to one-dimensional iteration...\n\t\tif ( ns === K-1 ) {\n\t\t\t// Get the index of the non-singleton dimension...\n\t\t\tfor ( i = 0; i < K; i++ ) {\n\t\t\t\tif ( shl[ i ] !== 1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor ( j = 0; j < N; j++ ) {\n\t\t\t\tarr[ j ].strides = [ arr[j].strides[i] ];\n\t\t\t}\n\t\t\tslx = [ slx[i] ];\n\t\t\tsly = [ sly[i] ];\n\t\t\treturn UNARY[ 1 ]( fcn, arr, views, [ shl[i] ], slx, sly, strategyX, strategyY, opts ); // eslint-disable-line max-len\n\t\t}\n\t\tiox = iterationOrder( slx ); // +/-1\n\t\tioy = iterationOrder( sly ); // +/-1\n\n\t\t// Determine whether we can avoid blocked iteration...\n\t\tord = strides2order( slx );\n\t\tif ( iox !== 0 && ioy !== 0 && ord === strides2order( sly ) && K <= MAX_DIMS ) { // eslint-disable-line max-len\n\t\t\t// So long as iteration for each respective array always moves in the same direction (i.e., no mixed sign strides) and the memory layouts are the same, we can leverage cache-optimal (i.e., normal) nested loops without resorting to blocked iteration...\n\t\t\treturn UNARY[ K ]( fcn, arr, views, shl, slx, sly, ord === 1, strategyX, strategyY, opts ); // eslint-disable-line max-len\n\t\t}\n\t\t// Check whether blocked iteration is prohibited due to a requirement that the order of element traversal match the memory layout of a provided input ndarray...\n\t\tif ( OPTS.strictTraversalOrder && K <= MAX_DIMS ) {\n\t\t\t// We have two choices here: (1) we could copy to contiguous memory or (2) we can perform normal nested loop iteration, even though this is not cache-optimal based on the assumption that, while this may hurt performance, for many cases (i.e., smaller ndarrays), this should be fine and likely better than performing a complete copy...\n\t\t\treturn UNARY[ K ]( fcn, arr, views, shl, slx, sly, ord === 1, strategyX, strategyY, opts ); // eslint-disable-line max-len\n\t\t}\n\t\t// At this point, we're either dealing with non-contiguous n-dimensional arrays, high dimensional n-dimensional arrays, and/or arrays having differing memory layouts, so our only hope is that we can still perform blocked iteration...\n\n\t\t// Determine whether we can perform blocked iteration...\n\t\tif ( K <= MAX_DIMS ) {\n\t\t\treturn BLOCKED_UNARY[ K-2 ]( fcn, arr, views, shl, slx, sly, strategyX, strategyY, opts ); // eslint-disable-line max-len\n\t\t}\n\t\t// Perform linear view iteration without regard for how data is stored in memory (i.e., take the slow path)...\n\t\tunarynd( fcn, arr, views, shl, slx, sly, strategyX, strategyY, opts );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = factory;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar factory = require( './main_factory.js' );\n\n\n// MAIN //\n\n/**\n* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n*\n* @name unaryStrided1d\n* @type {Function}\n* @param {Function} fcn - wrapper for a one-dimensional strided array function\n* @param {ArrayLikeObject<Object>} arrays - array-like object containing ndarrays\n* @param {IntegerArray} dims - list of dimensions to which to apply a strided array function\n* @param {Options} [options] - function options\n* @throws {Error} arrays must have the expected number of dimensions\n* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n* @throws {Error} must provide unique dimension indices\n* @throws {Error} arrays must have the same loop dimension sizes\n* @returns {void}\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 3 ],\n*     'strides': [ 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply strided function:\n* unaryStrided1d( wrapper, [ x, y, initial ], [ 2, 3 ] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [],\n*     'strides': [ 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply strided function:\n* unaryStrided1d( wrapper, [ x, y, initial ], [ 0, 1, 2, 3 ] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 15.0, 21.0 ], [ 28.0, 36.0 ] ], [ [ 45.0, 55.0 ], [ 66.0, 78.0 ] ] ] ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 3, 2, 2 ];\n* var ysh = [ 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 4, 2, 1 ];\n* var sy = [ 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 3, 2, 2 ],\n*     'strides': [ 0, 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply strided function:\n* unaryStrided1d( wrapper, [ x, y, initial ], [] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ 1.0, 2.0 ], [ 3.0, 4.0 ] ], [ [ 5.0, 6.0 ], [ 7.0, 8.0 ] ], [ [ 9.0, 10.0 ], [ 11.0, 12.0 ] ] ]\n*/\nvar unaryStrided1d = factory();\n\n\n// EXPORTS //\n\nmodule.exports = unaryStrided1d;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isFunction = require( '@stdlib/assert-is-function' );\nvar mainFactory = require( './main_factory.js' );\nvar main = require( './main.js' );\n\n\n// MAIN //\n\n/**\n* Return a function for applying a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigning results to a provided output ndarray.\n*\n* @param {Function} [fcn] - wrapper for a one-dimensional strided array function\n* @param {Options} [options] - function options\n* @param {boolean} [options.strictTraversalOrder=false] - boolean specifying whether to require that element traversal match the memory layout of an input ndarray\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @returns {Function} function for applying a strided array function\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 3 ],\n*     'strides': [ 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Create a function for applying a strided function:\n* var cusum = factory( wrapper );\n* // returns <Function>\n*\n* // Apply strided function:\n* cusum( [ x, y, initial ], [ 2, 3 ] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ]\n*/\nfunction factory() {\n\tvar nargs;\n\tvar unary;\n\tvar fcn;\n\tvar f;\n\n\tnargs = arguments.length;\n\n\t// Case: factory()\n\tif ( nargs === 0 ) {\n\t\tunary = main;\n\t\tf = wrap;\n\t}\n\t// Case: factory( fcn, opts )\n\telse if ( nargs > 1 ) {\n\t\tunary = mainFactory( arguments[ 1 ] );\n\t\tfcn = arguments[ 0 ];\n\t\tf = apply;\n\t}\n\t// Case: factory( fcn )\n\telse if ( isFunction( arguments[ 0 ] ) ) {\n\t\tunary = main;\n\t\tfcn = arguments[ 0 ];\n\t\tf = apply;\n\t}\n\t// Case: factory( opts )\n\telse {\n\t\tunary = mainFactory( arguments[ 0 ] );\n\t\tf = wrap;\n\t}\n\treturn f;\n\n\t/**\n\t* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n\t*\n\t* @private\n\t* @param {ArrayLikeObject<Object>} arrays - array-like object containing ndarrays\n\t* @param {IntegerArray} dims - list of dimensions to which to apply a strided array function\n\t* @param {Options} [options] - function options\n\t* @returns {void}\n\t*/\n\tfunction apply( arrays, dims, options ) {\n\t\tvar opts;\n\t\tif ( arguments.length > 2 ) {\n\t\t\topts = options;\n\t\t} else {\n\t\t\topts = {};\n\t\t}\n\t\treturn unary( fcn, arrays, dims, opts );\n\t}\n\n\t/**\n\t* Applies a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assigns results to a provided output ndarray.\n\t*\n\t* @private\n\t* @param {Function} fcn - wrapper for a one-dimensional strided array function\n\t* @param {ArrayLikeObject<Object>} arrays - array-like object containing ndarrays\n\t* @param {IntegerArray} dims - list of dimensions to which to apply a strided array function\n\t* @param {Options} [options] - function options\n\t* @returns {void}\n\t*/\n\tfunction wrap( fcn, arrays, dims, options ) {\n\t\tvar opts;\n\t\tif ( arguments.length > 3 ) {\n\t\t\topts = options;\n\t\t} else {\n\t\t\topts = {};\n\t\t}\n\t\treturn unary( fcn, arrays, dims, opts );\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = factory;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Apply a one-dimensional strided array function to a list of specified dimensions in an input ndarray and assign results to a provided output ndarray.\n*\n* @module @stdlib/ndarray-base-unary-strided1d\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n* var unaryStrided1d = require( '@stdlib/ndarray-base-unary-strided1d' );\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 3 ],\n*     'strides': [ 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Apply strided function:\n* unaryStrided1d( wrapper, [ x, y, initial ], [ 2, 3 ] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ]\n*\n* @example\n* var Float64Array = require( '@stdlib/array-float64' );\n* var ndarray2array = require( '@stdlib/ndarray-base-to-array' );\n* var getStride = require( '@stdlib/ndarray-base-stride' );\n* var getOffset = require( '@stdlib/ndarray-base-offset' );\n* var getData = require( '@stdlib/ndarray-base-data-buffer' );\n* var numelDimension = require( '@stdlib/ndarray-base-numel-dimension' );\n* var gcusum = require( '@stdlib/blas-ext-base-gcusum' ).ndarray;\n* var unaryStrided1d = require( '@stdlib/ndarray-base-unary-strided1d' );\n*\n* function wrapper( arrays ) {\n*     var x = arrays[ 0 ];\n*     var y = arrays[ 1 ];\n*     var s = arrays[ 2 ];\n*     return gcusum( numelDimension( x, 0 ), getData( s )[ getOffset( s ) ], getData( x ), getStride( x, 0 ), getOffset( x ), getData( y ), getStride( y, 0 ), getOffset( y ) );\n* }\n*\n* // Create data buffers:\n* var xbuf = new Float64Array( [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] );\n* var ybuf = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ] );\n*\n* // Define the array shapes:\n* var xsh = [ 1, 3, 2, 2 ];\n* var ysh = [ 1, 3, 2, 2 ];\n*\n* // Define the array strides:\n* var sx = [ 12, 4, 2, 1 ];\n* var sy = [ 12, 4, 2, 1 ];\n*\n* // Define the index offsets:\n* var ox = 0;\n* var oy = 0;\n*\n* // Create an input ndarray-like object:\n* var x = {\n*     'dtype': 'float64',\n*     'data': xbuf,\n*     'shape': xsh,\n*     'strides': sx,\n*     'offset': ox,\n*     'order': 'row-major'\n* };\n*\n* // Create an ndarray-like object for the initial sum:\n* var initial = {\n*     'dtype': 'float64',\n*     'data': new Float64Array( [ 0.0 ] ),\n*     'shape': [ 1, 3 ],\n*     'strides': [ 0, 0 ],\n*     'offset': 0,\n*     'order': 'row-major'\n* };\n*\n* // Create an output ndarray-like object:\n* var y = {\n*     'dtype': 'float64',\n*     'data': ybuf,\n*     'shape': ysh,\n*     'strides': sy,\n*     'offset': oy,\n*     'order': 'row-major'\n* };\n*\n* // Create a function for applying a strided function:\n* var cusum = unaryStrided1d.factory( wrapper );\n* // returns <Function>\n*\n* // Apply strided function:\n* cusum( [ x, y, initial ], [ 2, 3 ] );\n*\n* var arr = ndarray2array( y.data, y.shape, y.strides, y.offset, y.order );\n* // returns [ [ [ [ 1.0, 3.0 ], [ 6.0, 10.0 ] ], [ [ 5.0, 11.0 ], [ 18.0, 26.0 ] ], [ [ 9.0, 19.0 ], [ 30.0, 42.0 ] ] ] ]\n*/\n\n// MODULES //\n\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar factory = require( './factory.js' );\nvar main = require( './main.js' );\n\n\n// MAIN //\n\nsetReadOnly( main, 'factory', factory );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "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",
  "names": ["require_initialize_array_views", "__commonJSMin", "exports", "module", "initializeViews", "arrays", "out", "v", "i", "require_strategy", "__commonJSMin", "exports", "module", "iterationOrder", "minmaxViewBufferIndex", "ndarraylike2object", "assign", "ndarraylike2ndarray", "emptyLike", "identity", "x", "broadcast", "squeeze", "arr", "index", "sh", "sx", "reshape", "contiguous", "len", "iox", "xmmv", "ind", "copyToWorkspace", "workspace", "view", "copyFromWorkspace", "copy", "strategy", "ndims", "ns", "i", "require_defaults", "__commonJSMin", "exports", "module", "defaults", "require_validate", "__commonJSMin", "exports", "module", "isObject", "hasOwnProp", "isBoolean", "format", "validate", "opts", "options", "require_increment_offsets", "__commonJSMin", "exports", "module", "incrementOffsets", "offsets", "inc", "i", "require_set_view_offsets", "__commonJSMin", "exports", "module", "setViewOffsets", "views", "offsets", "i", "require_offsets", "__commonJSMin", "exports", "module", "offsets", "arrays", "out", "i", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "takeIndexed", "copyIndexed", "zeros", "incrementOffsets", "setViewOffsets", "offsets", "blockedunary2d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "strategyX", "strategyY", "opts", "bsize", "dv0", "dv1", "ov1", "sh", "s0", "s1", "sv", "ov", "iv", "i0", "i1", "j0", "j1", "x", "y", "v", "o", "k", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "takeIndexed", "copyIndexed", "zeros", "incrementOffsets", "setViewOffsets", "offsets", "blockedunary3d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "strategyX", "strategyY", "opts", "bsize", "dv0", "dv1", "dv2", "ov1", "ov2", "sh", "s0", "s1", "s2", "sv", "ov", "iv", "i0", "i1", "i2", "j0", "j1", "j2", "N", "x", "y", "v", "o", "k", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "takeIndexed", "copyIndexed", "zeros", "incrementOffsets", "setViewOffsets", "offsets", "blockedunary4d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "strategyX", "strategyY", "opts", "bsize", "dv0", "dv1", "dv2", "dv3", "ov1", "ov2", "ov3", "sh", "s0", "s1", "s2", "s3", "sv", "ov", "iv", "i0", "i1", "i2", "i3", "j0", "j1", "j2", "j3", "N", "x", "y", "v", "o", "k", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "takeIndexed", "copyIndexed", "zeros", "incrementOffsets", "setViewOffsets", "offsets", "blockedunary5d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "strategyX", "strategyY", "opts", "bsize", "dv0", "dv1", "dv2", "dv3", "dv4", "ov1", "ov2", "ov3", "ov4", "sh", "s0", "s1", "s2", "s3", "s4", "sv", "ov", "iv", "i0", "i1", "i2", "i3", "i4", "j0", "j1", "j2", "j3", "j4", "N", "x", "y", "v", "o", "k", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "takeIndexed", "copyIndexed", "zeros", "incrementOffsets", "setViewOffsets", "offsets", "blockedunary6d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "strategyX", "strategyY", "opts", "bsize", "dv0", "dv1", "dv2", "dv3", "dv4", "dv5", "ov1", "ov2", "ov3", "ov4", "ov5", "sh", "s0", "s1", "s2", "s3", "s4", "s5", "sv", "ov", "iv", "i0", "i1", "i2", "i3", "i4", "i5", "j0", "j1", "j2", "j3", "j4", "j5", "N", "x", "y", "v", "o", "k", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "takeIndexed", "copyIndexed", "zeros", "incrementOffsets", "setViewOffsets", "offsets", "blockedunary7d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "strategyX", "strategyY", "opts", "bsize", "dv0", "dv1", "dv2", "dv3", "dv4", "dv5", "dv6", "ov1", "ov2", "ov3", "ov4", "ov5", "ov6", "sh", "s0", "s1", "s2", "s3", "s4", "s5", "s6", "sv", "ov", "iv", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "j0", "j1", "j2", "j3", "j4", "j5", "j6", "N", "x", "y", "v", "o", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "takeIndexed", "copyIndexed", "zeros", "incrementOffsets", "setViewOffsets", "offsets", "blockedunary8d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "strategyX", "strategyY", "opts", "bsize", "dv0", "dv1", "dv2", "dv3", "dv4", "dv5", "dv6", "dv7", "ov1", "ov2", "ov3", "ov4", "ov5", "ov6", "ov7", "sh", "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "sv", "ov", "iv", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "j0", "j1", "j2", "j3", "j4", "j5", "j6", "j7", "N", "x", "y", "v", "o", "k", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "takeIndexed", "copyIndexed", "zeros", "incrementOffsets", "setViewOffsets", "offsets", "blockedunary9d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "strategyX", "strategyY", "opts", "bsize", "dv0", "dv1", "dv2", "dv3", "dv4", "dv5", "dv6", "dv7", "dv8", "ov1", "ov2", "ov3", "ov4", "ov5", "ov6", "ov7", "ov8", "sh", "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "sv", "ov", "iv", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "i8", "j0", "j1", "j2", "j3", "j4", "j5", "j6", "j7", "j8", "N", "x", "y", "v", "o", "k", "require_d_blocked", "__commonJSMin", "exports", "module", "loopOrder", "blockSize", "takeIndexed", "copyIndexed", "zeros", "incrementOffsets", "setViewOffsets", "offsets", "blockedunary10d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "strategyX", "strategyY", "opts", "bsize", "dv0", "dv1", "dv2", "dv3", "dv4", "dv5", "dv6", "dv7", "dv8", "dv9", "ov1", "ov2", "ov3", "ov4", "ov5", "ov6", "ov7", "ov8", "ov9", "sh", "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "sv", "ov", "iv", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "i8", "i9", "j0", "j1", "j2", "j3", "j4", "j5", "j6", "j7", "j8", "j9", "N", "x", "y", "v", "o", "k", "require_d", "__commonJSMin", "exports", "module", "unary0d", "fcn", "arrays", "strategyX", "strategyY", "opts", "require_d", "__commonJSMin", "exports", "module", "copyIndexed", "incrementOffsets", "setViewOffsets", "offsets", "unary1d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "strategyX", "strategyY", "opts", "dv0", "S0", "iv", "i0", "v", "require_d", "__commonJSMin", "exports", "module", "copyIndexed", "incrementOffsets", "setViewOffsets", "offsets", "unary2d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "isRowMajor", "strategyX", "strategyY", "opts", "dv0", "dv1", "S0", "S1", "sv", "iv", "i0", "i1", "v", "i", "require_d", "__commonJSMin", "exports", "module", "copyIndexed", "incrementOffsets", "setViewOffsets", "offsets", "unary3d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "isRowMajor", "strategyX", "strategyY", "opts", "dv0", "dv1", "dv2", "S0", "S1", "S2", "sv", "iv", "i0", "i1", "i2", "v", "i", "require_d", "__commonJSMin", "exports", "module", "copyIndexed", "incrementOffsets", "setViewOffsets", "offsets", "unary4d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "isRowMajor", "strategyX", "strategyY", "opts", "dv0", "dv1", "dv2", "dv3", "S0", "S1", "S2", "S3", "sv", "iv", "i0", "i1", "i2", "i3", "v", "i", "require_d", "__commonJSMin", "exports", "module", "copyIndexed", "incrementOffsets", "setViewOffsets", "offsets", "unary5d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "isRowMajor", "strategyX", "strategyY", "opts", "dv0", "dv1", "dv2", "dv3", "dv4", "S0", "S1", "S2", "S3", "S4", "sv", "iv", "i0", "i1", "i2", "i3", "i4", "v", "i", "require_d", "__commonJSMin", "exports", "module", "copyIndexed", "incrementOffsets", "setViewOffsets", "offsets", "unary6d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "isRowMajor", "strategyX", "strategyY", "opts", "dv0", "dv1", "dv2", "dv3", "dv4", "dv5", "S0", "S1", "S2", "S3", "S4", "S5", "sv", "iv", "i0", "i1", "i2", "i3", "i4", "i5", "v", "i", "require_d", "__commonJSMin", "exports", "module", "copyIndexed", "incrementOffsets", "setViewOffsets", "offsets", "unary7d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "isRowMajor", "strategyX", "strategyY", "opts", "dv0", "dv1", "dv2", "dv3", "dv4", "dv5", "dv6", "S0", "S1", "S2", "S3", "S4", "S5", "S6", "sv", "iv", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "v", "i", "require_d", "__commonJSMin", "exports", "module", "copyIndexed", "incrementOffsets", "setViewOffsets", "offsets", "unary8d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "isRowMajor", "strategyX", "strategyY", "opts", "dv0", "dv1", "dv2", "dv3", "dv4", "dv5", "dv6", "dv7", "S0", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "sv", "iv", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "v", "i", "require_d", "__commonJSMin", "exports", "module", "copyIndexed", "incrementOffsets", "setViewOffsets", "offsets", "unary9d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "isRowMajor", "strategyX", "strategyY", "opts", "dv0", "dv1", "dv2", "dv3", "dv4", "dv5", "dv6", "dv7", "dv8", "S0", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "sv", "iv", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "i8", "v", "i", "require_d", "__commonJSMin", "exports", "module", "copyIndexed", "incrementOffsets", "setViewOffsets", "offsets", "unary10d", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "isRowMajor", "strategyX", "strategyY", "opts", "dv0", "dv1", "dv2", "dv3", "dv4", "dv5", "dv6", "dv7", "dv8", "dv9", "S0", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "sv", "iv", "i0", "i1", "i2", "i3", "i4", "i5", "i6", "i7", "i8", "i9", "v", "i", "require_nd", "__commonJSMin", "exports", "module", "numel", "vind2bind", "copyIndexed", "zeros", "setViewOffsets", "offsets", "MODE", "unarynd", "fcn", "arrays", "views", "shape", "stridesX", "stridesY", "strategyX", "strategyY", "opts", "len", "arr", "iv", "io", "N", "v", "i", "j", "require_main_factory", "__commonJSMin", "exports", "module", "ndarray2object", "normalizeIndices", "indicesComplement", "takeIndexed2", "takeIndexed", "iterationOrder", "strides2order", "numel", "join", "format", "initializeViews", "strategy", "defaults", "validate", "blockedunary2d", "blockedunary3d", "blockedunary4d", "blockedunary5d", "blockedunary6d", "blockedunary7d", "blockedunary8d", "blockedunary9d", "blockedunary10d", "unary0d", "unary1d", "unary2d", "unary3d", "unary4d", "unary5d", "unary6d", "unary7d", "unary8d", "unary9d", "unary10d", "unarynd", "UNARY", "BLOCKED_UNARY", "MAX_DIMS", "factory", "options", "OPTS", "err", "unaryStrided1d", "fcn", "arrays", "dims", "strategyX", "strategyY", "views", "ndims", "ldims", "opts", "arr", "tmp", "len", "shl", "shc", "shx", "iox", "ioy", "scx", "scy", "slx", "sly", "ord", "ns", "d", "s", "N", "M", "x", "y", "i", "j", "require_main", "__commonJSMin", "exports", "module", "factory", "unaryStrided1d", "require_factory", "__commonJSMin", "exports", "module", "isFunction", "mainFactory", "main", "factory", "nargs", "unary", "fcn", "f", "wrap", "apply", "arrays", "dims", "options", "opts", "setReadOnly", "factory", "main"]
}
